/**
 * Confidential Transfer Composable
 *
 * Real implementation of confidential transfers using Token-2022
 * with ZK proofs for privacy.
 *
 * Maintains the same API as the mock for drop-in replacement.
 */

import { ref, type Ref } from 'vue';
import { Connection, PublicKey, Transaction, Keypair, SystemProgram } from '@solana/web3.js';
import {
  TOKEN_2022_PROGRAM_ID,
  ExtensionType,
  getMintLen,
  createInitializeMintInstruction,
  getAssociatedTokenAddressSync,
  createAssociatedTokenAccountInstruction,
  createMintToInstruction,
} from '@solana/spl-token';
import type { WalletAdapter } from '@solana/wallet-adapter-base';
import { createMemoInstruction } from '@solana/spl-memo';

// Services
import { loadZkSdk } from '~/services/zkSdk';
import {
  deriveKeys,
  getElGamalPublicKeyHex,
  getElGamalKeypair,
  getAeKey,
  hasKeys,
  isKeysDerivedFor,
} from '~/services/elGamalKeyManager';
import {
  createInitializeConfidentialTransferMintInstruction,
  createReallocateInstruction,
  createConfigureAccountInstruction,
  createDepositInstruction,
  createApplyPendingBalanceInstruction,
  createWithdrawInstruction,
  createConfidentialTransferInstruction,
  createVerifyPubkeyValidityInstruction,
  createVerifyCiphertextCommitmentEqualityInstruction,
  createVerifyBatchedRangeProofU64Instruction,
  createVerifyBatchedRangeProofU128Instruction,
  createVerifyBatchedGroupedCiphertext3HandlesValidityInstruction,
  readPendingBalanceCreditCounter,
  readPendingBalanceCiphertexts,
  readDecryptableAvailableBalance,
  readAvailableBalanceCiphertext,
  readElGamalPubkey,
  hasConfidentialTransferExtension,
  getContextStateAccountSize,
  ZK_ELGAMAL_PROOF_PROGRAM_ID,
} from '~/services/confidentialInstructions';
import {
  combineLowHighCiphertexts,
  subtractCiphertexts,
} from '~/services/confidentialCrypto';
import {
  signAndSendTransaction,
  buildAndSendTransaction,
} from '~/services/walletSigner';

// ============================================
// Configuration
// ============================================

const RPC_URL = 'http://127.0.0.1:8899';
const DECIMALS = 9;

// Module-level state (shared across components)
const loading = ref(false);
const error = ref<string | null>(null);
const elGamalPublicKey = ref<string | null>(null);
const testMint = ref<string | null>(null);

// Withdrawal progress tracking
export interface WithdrawProgress {
  step: number;
  totalSteps: number;
  currentStep: string;
}
const withdrawProgress = ref<WithdrawProgress | null>(null);

// Transaction history (fetched from RPC, not stored locally)
export interface CTTransaction {
  id: string;
  type: 'deposit' | 'apply' | 'withdraw' | 'transfer' | 'mint';
  amount: number;
  signature: string;
  timestamp: number;
  status: 'success' | 'failed';
}
const transactions = ref<CTTransaction[]>([]);

// Clear transaction history (just clears the in-memory list)
function clearTransactionHistory(): void {
  transactions.value = [];
  console.log('[CT] Transaction history cleared');
}

// Token mint address (stored in localStorage for persistence)
const MINT_STORAGE_KEY = 'veil-ct-mint';

// ============================================
// Hardcoded Constants (generated by scripts/generate-constants.ts)
// ============================================

// Mint Keypair - same across all browsers
// Public Key: Dbz8dLkGA6PErb4VxRFr8GDdk27J9YLVbFCmhq7bdtPH
const MINT_SECRET_KEY = new Uint8Array([
  178, 109, 90, 187, 249, 42, 157, 28, 201, 124, 34, 48, 67, 55, 77, 222,
  79, 151, 120, 127, 52, 210, 131, 113, 68, 176, 50, 242, 63, 197, 100, 161,
  187, 66, 150, 227, 133, 54, 40, 189, 162, 166, 247, 182, 172, 216, 141, 109,
  159, 76, 214, 10, 114, 90, 225, 141, 51, 127, 254, 34, 76, 36, 112, 184,
]);

// Auditor ElGamal Public Key (32 bytes) - valid Ristretto curve point
const AUDITOR_ELGAMAL_PUBKEY = new Uint8Array([
  0x74, 0xae, 0x61, 0x72, 0xca, 0x26, 0x63, 0xd0,
  0x69, 0xca, 0x4c, 0xf1, 0x70, 0xcf, 0x50, 0x8a,
  0xcd, 0xcf, 0xa7, 0xea, 0x23, 0x00, 0xaa, 0x0c,
  0x96, 0x04, 0x1b, 0x2b, 0x8d, 0x85, 0xc0, 0x68,
]);

/**
 * Get the mint keypair from hardcoded secret key
 * This ensures the same mint address across all browsers/sessions
 */
function getMintKeypair(): Keypair {
  return Keypair.fromSecretKey(MINT_SECRET_KEY);
}


// ============================================
// Helper Functions
// ============================================

function getWalletAddress(wallet: any): string | null {
  if (!wallet?.publicKey) return null;
  return typeof wallet.publicKey === 'string'
    ? wallet.publicKey
    : wallet.publicKey.toBase58?.() || wallet.publicKey.toString();
}

function getConnection(): Connection {
  return new Connection(RPC_URL, { commitment: 'confirmed' });
}

// ============================================
// Composable
// ============================================

export function useConfidentialTransfer() {
  /**
   * Derive ElGamal Keypair deterministically from wallet signature
   * Same wallet = same signature = same keys (across browsers/sessions)
   */
  async function deriveElGamalKeypair(wallet: any): Promise<void> {
    const walletAddress = getWalletAddress(wallet);
    if (!walletAddress) {
      throw new Error('Wallet not connected');
    }

    loading.value = true;
    error.value = null;

    try {
      // Check if already derived for this wallet
      if (isKeysDerivedFor(walletAddress)) {
        elGamalPublicKey.value = getElGamalPublicKeyHex();
        console.log('[CT] Keys already derived for wallet');
        return;
      }

      // Derive keys from wallet signature (deterministic!)
      await deriveKeys(wallet as WalletAdapter);
      elGamalPublicKey.value = getElGamalPublicKeyHex();
      console.log('[CT] ElGamal keypair derived:', elGamalPublicKey.value?.slice(0, 16) + '...');

      // Verify keys match on-chain (they should, since derivation is deterministic)
      if (testMint.value) {
        const connection = getConnection();
        const walletPubkey = new PublicKey(walletAddress);
        const mintPubkey = new PublicKey(testMint.value);

        const ata = getAssociatedTokenAddressSync(
          mintPubkey,
          walletPubkey,
          false,
          TOKEN_2022_PROGRAM_ID,
        );

        const accountInfo = await connection.getAccountInfo(ata);
        if (accountInfo && hasConfidentialTransferExtension(accountInfo.data)) {
          const onChainPubkeyBytes = readElGamalPubkey(accountInfo.data);
          const localPubkeyBytes = getElGamalKeypair().pubkey().toBytes();

          if (onChainPubkeyBytes) {
            const onChainHex = Array.from(onChainPubkeyBytes).map(b => b.toString(16).padStart(2, '0')).join('');
            const localHex = Array.from(localPubkeyBytes).map(b => b.toString(16).padStart(2, '0')).join('');
            const keysMatch = onChainHex === localHex;

            console.log('[CT] On-chain key:', onChainHex.slice(0, 16) + '...');
            console.log('[CT] Local key:   ', localHex.slice(0, 16) + '...');
            console.log('[CT] Keys match:', keysMatch ? '✓ YES' : '✗ NO');

            if (!keysMatch) {
              // This shouldn't happen with deterministic derivation unless
              // the account was configured with old random keys
              console.warn('[CT] Key mismatch! Account may have been configured with different keys.');
              console.warn('[CT] Will reconfigure account with current deterministic keys...');
              await configureConfidentialTransferAccount(wallet);
            }
          }
        }
      }
    } catch (e: any) {
      error.value = e.message || 'Failed to derive keypair';
      throw e;
    } finally {
      loading.value = false;
    }
  }

  /**
   * Setup Test Mint with confidential transfer extension
   */
  async function setupTestMint(wallet: any): Promise<string> {
    const walletAddress = getWalletAddress(wallet);
    if (!walletAddress) {
      throw new Error('Wallet not connected');
    }

    loading.value = true;
    error.value = null;

    try {
      const connection = getConnection();

      // Use deterministic mint keypair - same address across all browsers
      const mint = getMintKeypair();
      const mintAddress = mint.publicKey.toBase58();

      // Check if mint already exists on-chain (may have been created by another browser)
      const mintInfo = await connection.getAccountInfo(mint.publicKey);
      if (mintInfo) {
        testMint.value = mintAddress;
        localStorage.setItem(MINT_STORAGE_KEY, mintAddress);
        console.log('[CT] Using existing deterministic mint:', mintAddress);
        return mintAddress;
      }

      console.log('[CT] Creating new deterministic mint:', mintAddress);
      const mintLen = getMintLen([ExtensionType.ConfidentialTransferMint]);
      const mintRent = await connection.getMinimumBalanceForRentExemption(mintLen);

      // Use hardcoded auditor pubkey (same across all browsers)
      console.log('[CT] Using hardcoded auditor pubkey');

      // Create mint account
      const createAccountIx = SystemProgram.createAccount({
        fromPubkey: wallet.publicKey,
        newAccountPubkey: mint.publicKey,
        space: mintLen,
        lamports: mintRent,
        programId: TOKEN_2022_PROGRAM_ID,
      });

      // Initialize confidential transfer mint extension
      const initConfidentialIx = createInitializeConfidentialTransferMintInstruction(
        mint.publicKey,
        wallet.publicKey,
        true, // auto-approve new accounts
        AUDITOR_ELGAMAL_PUBKEY,
      );

      // Initialize mint - use mint keypair as authority so any browser can mint
      const initMintIx = createInitializeMintInstruction(
        mint.publicKey,
        DECIMALS,
        mint.publicKey, // Use deterministic mint keypair as authority
        null,
        TOKEN_2022_PROGRAM_ID,
      );

      const transaction = new Transaction().add(
        createAccountIx,
        initConfidentialIx,
        initMintIx,
      );

      const sig = await signAndSendTransaction(connection, wallet as WalletAdapter, transaction, {
        additionalSigners: [mint],
        description: 'create confidential mint',
      });

      localStorage.setItem(MINT_STORAGE_KEY, mintAddress);
      testMint.value = mintAddress;

      console.log('[CT] Created confidential mint:', mintAddress, 'tx:', sig);
      return mintAddress;
    } catch (e: any) {
      error.value = e.message || 'Failed to setup mint';
      throw e;
    } finally {
      loading.value = false;
    }
  }

  /**
   * Setup Token Account (ATA)
   */
  async function setupTokenAccount(wallet: any): Promise<string> {
    const walletAddress = getWalletAddress(wallet);
    if (!walletAddress || !testMint.value) {
      throw new Error('Wallet not connected or mint not setup');
    }

    loading.value = true;
    error.value = null;

    try {
      const connection = getConnection();
      const mintPubkey = new PublicKey(testMint.value);
      const walletPubkey = new PublicKey(walletAddress);

      const ata = getAssociatedTokenAddressSync(
        mintPubkey,
        walletPubkey,
        false,
        TOKEN_2022_PROGRAM_ID,
      );

      // Check if ATA already exists
      const ataInfo = await connection.getAccountInfo(ata);
      if (ataInfo) {
        console.log('[CT] ATA already exists:', ata.toBase58());
        return ata.toBase58();
      }

      // Create ATA
      const createAtaIx = createAssociatedTokenAccountInstruction(
        walletPubkey,
        ata,
        walletPubkey,
        mintPubkey,
        TOKEN_2022_PROGRAM_ID,
      );

      const sig = await buildAndSendTransaction(
        connection,
        wallet as WalletAdapter,
        [createAtaIx],
        { description: 'create token account' },
      );

      console.log('[CT] Created ATA:', ata.toBase58(), 'tx:', sig);
      return ata.toBase58();
    } catch (e: any) {
      error.value = e.message || 'Failed to setup token account';
      throw e;
    } finally {
      loading.value = false;
    }
  }

  /**
   * Configure account for confidential transfers
   * Stores ElGamal public key on-chain
   */
  async function configureConfidentialTransferAccount(wallet: any): Promise<string> {
    const walletAddress = getWalletAddress(wallet);
    if (!walletAddress) {
      throw new Error('Wallet not connected');
    }

    if (!hasKeys()) {
      throw new Error('ElGamal keypair not derived. Call deriveElGamalKeypair first.');
    }

    if (!testMint.value) {
      throw new Error('Mint not setup. Call setupTestMint first.');
    }

    loading.value = true;
    error.value = null;

    try {
      const connection = getConnection();
      const zkSdk = await loadZkSdk();
      const walletPubkey = new PublicKey(walletAddress);
      const mintPubkey = new PublicKey(testMint.value);

      const ata = getAssociatedTokenAddressSync(
        mintPubkey,
        walletPubkey,
        false,
        TOKEN_2022_PROGRAM_ID,
      );

      // Check if ATA exists
      let accountInfo = await connection.getAccountInfo(ata);

      // Create ATA if it doesn't exist
      if (!accountInfo) {
        console.log('[CT] ATA does not exist, creating...');
        const createAtaIx = createAssociatedTokenAccountInstruction(
          walletPubkey,
          ata,
          walletPubkey,
          mintPubkey,
          TOKEN_2022_PROGRAM_ID,
        );
        await buildAndSendTransaction(
          connection,
          wallet as WalletAdapter,
          [createAtaIx],
          { description: 'create token account' },
        );
        console.log('[CT] ATA created:', ata.toBase58());
        // Re-fetch account info
        accountInfo = await connection.getAccountInfo(ata);
      }

      // Check if already configured
      console.log('[CT] === CONFIGURE ACCOUNT DEBUG ===');
      console.log('[CT] Wallet:', walletAddress);
      console.log('[CT] Mint:', testMint.value);
      console.log('[CT] Computed ATA:', ata.toBase58());
      console.log('[CT] Account exists:', !!accountInfo);
      console.log('[CT] Account data length:', accountInfo?.data.length || 0);

      if (accountInfo && hasConfidentialTransferExtension(accountInfo.data)) {
        console.log('[CT] Account already configured for confidential transfers');
        return 'already-configured';
      }
      console.log('[CT] Account NOT yet configured, setting up CT extension...');

      const elGamal = getElGamalKeypair();
      const aeKey = getAeKey();

      // Generate pubkey validity proof
      const proofData = new zkSdk.PubkeyValidityProofData(elGamal);
      const proofBytes = proofData.toBytes();
      proofData.verify();
      console.log('[CT] Pubkey validity proof generated and verified');

      // Encrypt zero balance
      const zeroBalanceCiphertext = aeKey.encrypt(0n);
      const zeroBalanceBytes = zeroBalanceCiphertext.toBytes();

      // Build transaction
      const reallocateIx = createReallocateInstruction(
        ata,
        walletPubkey,
        walletPubkey,
        [ExtensionType.ConfidentialTransferAccount],
      );

      const verifyProofIx = createVerifyPubkeyValidityInstruction(proofBytes);

      const configureIx = createConfigureAccountInstruction(
        ata,
        mintPubkey,
        walletPubkey,
        zeroBalanceBytes,
        65536n, // max pending balance credit counter
        -1, // proof instruction offset (previous instruction)
      );

      const sig = await buildAndSendTransaction(
        connection,
        wallet as WalletAdapter,
        [reallocateIx, verifyProofIx, configureIx],
        { description: 'configure confidential account' },
      );

      console.log('[CT] Account configured for confidential transfers, tx:', sig);

      // Verify configuration was successful
      const verifyAccountInfo = await connection.getAccountInfo(ata);
      if (verifyAccountInfo && hasConfidentialTransferExtension(verifyAccountInfo.data)) {
        console.log('[CT] Configuration verified! Account now has CT extension');
        console.log('[CT] New account data length:', verifyAccountInfo.data.length);
      } else {
        console.error('[CT] WARNING: Configuration transaction succeeded but account does not have CT extension!');
        console.error('[CT] Account data length:', verifyAccountInfo?.data.length || 0);
      }

      return sig;
    } catch (e: any) {
      error.value = e.message || 'Failed to configure account';
      throw e;
    } finally {
      loading.value = false;
    }
  }

  /**
   * Mint test tokens (dev only)
   */
  async function mintTestTokens(
    wallet: any,
    amount: number,
    _token: 'SOL' | 'USDC' = 'USDC',
  ): Promise<string> {
    const walletAddress = getWalletAddress(wallet);
    if (!walletAddress || !testMint.value) {
      throw new Error('Wallet not connected or mint not setup');
    }

    loading.value = true;
    error.value = null;

    try {
      const connection = getConnection();
      const walletPubkey = new PublicKey(walletAddress);
      const mintPubkey = new PublicKey(testMint.value);

      const ata = getAssociatedTokenAddressSync(
        mintPubkey,
        walletPubkey,
        false,
        TOKEN_2022_PROGRAM_ID,
      );

      // Check if ATA exists, create if needed
      const ataInfo = await connection.getAccountInfo(ata);
      const instructions = [];

      if (!ataInfo) {
        console.log('[CT] ATA does not exist, creating...');
        const createAtaIx = createAssociatedTokenAccountInstruction(
          walletPubkey,
          ata,
          walletPubkey,
          mintPubkey,
          TOKEN_2022_PROGRAM_ID,
        );
        instructions.push(createAtaIx);
      }

      // Convert to token amount (with decimals)
      const tokenAmount = BigInt(Math.floor(amount * Math.pow(10, DECIMALS)));

      // Get the deterministic mint keypair (it's the mint authority)
      const mintKeypair = getMintKeypair();

      const mintToIx = createMintToInstruction(
        mintPubkey,
        ata,
        mintKeypair.publicKey, // Use mint keypair as authority
        tokenAmount,
        [],
        TOKEN_2022_PROGRAM_ID,
      );
      instructions.push(mintToIx);

      const sig = await signAndSendTransaction(
        connection,
        wallet as WalletAdapter,
        new Transaction().add(...instructions),
        {
          additionalSigners: [mintKeypair], // Sign with mint keypair
          description: 'mint test tokens',
        },
      );

      console.log(`[CT] Minted ${amount} tokens, tx:`, sig);
      return sig;
    } catch (e: any) {
      error.value = e.message || 'Failed to mint tokens';
      throw e;
    } finally {
      loading.value = false;
    }
  }

  /**
   * Get public (non-confidential) token balance
   */
  async function getPublicBalance(
    wallet: any,
    _token: 'SOL' | 'USDC' = 'USDC',
  ): Promise<number> {
    const walletAddress = getWalletAddress(wallet);
    if (!walletAddress || !testMint.value) return 0;

    try {
      const connection = getConnection();
      const walletPubkey = new PublicKey(walletAddress);
      const mintPubkey = new PublicKey(testMint.value);

      const ata = getAssociatedTokenAddressSync(
        mintPubkey,
        walletPubkey,
        false,
        TOKEN_2022_PROGRAM_ID,
      );

      const accountInfo = await connection.getAccountInfo(ata);
      if (!accountInfo) return 0;

      // Public balance is at offset 64 in the token account data (8 bytes)
      const publicBalance = accountInfo.data.readBigUInt64LE(64);
      return Number(publicBalance) / Math.pow(10, DECIMALS);
    } catch (e) {
      console.error('[CT] Error getting public balance:', e);
      return 0;
    }
  }

  /**
   * Get pending (deposited but not applied) balance
   * Requires ElGamal keypair to decrypt the ciphertexts
   */
  async function getPendingBalance(
    wallet: any,
    _token: 'SOL' | 'USDC' = 'USDC',
  ): Promise<number> {
    const walletAddress = getWalletAddress(wallet);
    if (!walletAddress || !testMint.value || !hasKeys()) {
      console.log('[CT] getPendingBalance: missing prerequisites', {
        wallet: !!walletAddress,
        mint: !!testMint.value,
        keys: hasKeys(),
      });
      return 0;
    }

    try {
      const connection = getConnection();
      const zkSdk = await loadZkSdk();
      const walletPubkey = new PublicKey(walletAddress);
      const mintPubkey = new PublicKey(testMint.value);
      const elGamal = getElGamalKeypair();

      const ata = getAssociatedTokenAddressSync(
        mintPubkey,
        walletPubkey,
        false,
        TOKEN_2022_PROGRAM_ID,
      );

      const accountInfo = await connection.getAccountInfo(ata);
      if (!accountInfo) {
        console.log('[CT] getPendingBalance: account not found');
        return 0;
      }

      console.log('[CT] getPendingBalance: account data length:', accountInfo.data.length);

      // Read pending balance ciphertexts
      const pendingCiphertexts = readPendingBalanceCiphertexts(accountInfo.data);
      if (!pendingCiphertexts) {
        console.log('[CT] getPendingBalance: no pending ciphertexts found');
        return 0;
      }

      console.log('[CT] getPendingBalance: found ciphertexts, lo length:', pendingCiphertexts.lo.length, 'hi length:', pendingCiphertexts.hi.length);

      // Log first few bytes to check if non-zero
      const loPreview = Array.from(pendingCiphertexts.lo.slice(0, 8)).map(b => b.toString(16).padStart(2, '0')).join(' ');
      const hiPreview = Array.from(pendingCiphertexts.hi.slice(0, 8)).map(b => b.toString(16).padStart(2, '0')).join(' ');
      console.log('[CT] getPendingBalance: lo first 8 bytes:', loPreview);
      console.log('[CT] getPendingBalance: hi first 8 bytes:', hiPreview);

      // Check if all zeros (no pending balance)
      const loAllZeros = pendingCiphertexts.lo.every(b => b === 0);
      const hiAllZeros = pendingCiphertexts.hi.every(b => b === 0);
      if (loAllZeros && hiAllZeros) {
        console.log('[CT] getPendingBalance: ciphertexts are all zeros (no pending balance)');
        return 0;
      }

      // DIAGNOSTIC: Check if our local ElGamal pubkey matches the one on-chain
      const onChainPubkeyBytes = readElGamalPubkey(accountInfo.data);
      const localPubkeyBytes = elGamal.pubkey().toBytes();
      if (onChainPubkeyBytes) {
        const onChainHex = Array.from(onChainPubkeyBytes).map(b => b.toString(16).padStart(2, '0')).join('');
        const localHex = Array.from(localPubkeyBytes).map(b => b.toString(16).padStart(2, '0')).join('');
        console.log('[CT] getPendingBalance: on-chain ElGamal pubkey:', onChainHex.slice(0, 32) + '...');
        console.log('[CT] getPendingBalance: local ElGamal pubkey:   ', localHex.slice(0, 32) + '...');
        const keysMatch = onChainHex === localHex;
        console.log('[CT] getPendingBalance: keys match:', keysMatch ? '✓ YES' : '✗ NO - THIS IS THE PROBLEM!');
        if (!keysMatch) {
          console.error('[CT] KEY MISMATCH: Your local ElGamal key does not match the one stored on-chain.');
          console.error('[CT] This means you configured the account with a different key (possibly in another browser or session).');
          console.error('[CT] Solution: Re-configure the account with your current key, or use the original wallet/browser.');
        }
      }

      // Parse ciphertexts
      const loCiphertext = zkSdk.ElGamalCiphertext.fromBytes(pendingCiphertexts.lo);
      const hiCiphertext = zkSdk.ElGamalCiphertext.fromBytes(pendingCiphertexts.hi);

      if (!loCiphertext || !hiCiphertext) {
        console.log('[CT] getPendingBalance: failed to parse ciphertexts', {
          loOk: !!loCiphertext,
          hiOk: !!hiCiphertext,
        });
        return 0;
      }

      // Decrypt using ElGamal secret key
      const secretKey = elGamal.secret();
      const loAmount = secretKey.decrypt(loCiphertext);
      const hiAmount = secretKey.decrypt(hiCiphertext);

      console.log('[CT] getPendingBalance: decrypted values - lo:', loAmount.toString(), 'hi:', hiAmount.toString());

      // Combine lo and hi (hi is shifted by 16 bits for u48 values, or 32 bits for larger)
      // For Token-2022 CT, pending balance uses 48-bit amounts split into two 24-bit parts
      // lo contains lower 16 bits, hi contains upper 32 bits
      const combined = loAmount + (hiAmount << 16n);
      console.log('[CT] getPendingBalance: combined raw:', combined.toString());

      const result = Number(combined) / Math.pow(10, DECIMALS);
      console.log('[CT] getPendingBalance: final result:', result);

      return result;
    } catch (e) {
      console.error('[CT] Error getting pending balance:', e);
      return 0;
    }
  }

  /**
   * Get confidential (available/private) balance
   */
  async function getConfidentialBalance(
    wallet: any,
    _token: 'SOL' | 'USDC' = 'USDC',
  ): Promise<number> {
    const walletAddress = getWalletAddress(wallet);
    if (!walletAddress || !testMint.value || !hasKeys()) return 0;

    try {
      const connection = getConnection();
      const zkSdk = await loadZkSdk();
      const walletPubkey = new PublicKey(walletAddress);
      const mintPubkey = new PublicKey(testMint.value);

      const ata = getAssociatedTokenAddressSync(
        mintPubkey,
        walletPubkey,
        false,
        TOKEN_2022_PROGRAM_ID,
      );

      const accountInfo = await connection.getAccountInfo(ata);
      if (!accountInfo) return 0;

      // Read the decryptable_available_balance from the extension
      const decryptableBytes = readDecryptableAvailableBalance(accountInfo.data);
      if (!decryptableBytes) return 0;

      // Decrypt using AE key
      const aeKey = getAeKey();
      const ciphertext = zkSdk.AeCiphertext.fromBytes(decryptableBytes);
      if (!ciphertext) return 0;

      const decrypted = ciphertext.decrypt(aeKey);
      if (decrypted === undefined) return 0;

      return Number(decrypted) / Math.pow(10, DECIMALS);
    } catch (e) {
      console.error('[CT] Error getting confidential balance:', e);
      return 0;
    }
  }

  /**
   * Deposit tokens to confidential balance (public -> pending)
   */
  async function depositToConfidential(
    wallet: any,
    amount: number,
    _token: 'SOL' | 'USDC' = 'USDC',
  ): Promise<string> {
    const walletAddress = getWalletAddress(wallet);
    if (!walletAddress || !testMint.value) {
      throw new Error('Wallet not connected or mint not setup');
    }

    loading.value = true;
    error.value = null;

    try {
      const connection = getConnection();
      const walletPubkey = new PublicKey(walletAddress);
      const mintPubkey = new PublicKey(testMint.value);

      const ata = getAssociatedTokenAddressSync(
        mintPubkey,
        walletPubkey,
        false,
        TOKEN_2022_PROGRAM_ID,
      );

      // Convert to token amount
      const tokenAmount = BigInt(Math.floor(amount * Math.pow(10, DECIMALS)));

      const depositIx = createDepositInstruction(
        ata,
        mintPubkey,
        walletPubkey,
        tokenAmount,
        DECIMALS,
      );

      const sig = await buildAndSendTransaction(
        connection,
        wallet as WalletAdapter,
        [depositIx],
        { description: 'deposit to confidential' },
      );

      console.log(`[CT] Deposited ${amount} tokens to pending, tx:`, sig);
      return sig;
    } catch (e: any) {
      error.value = e.message || 'Failed to deposit';
      throw e;
    } finally {
      loading.value = false;
    }
  }

  /**
   * Apply pending balance (pending -> available)
   */
  async function applyPendingBalance(
    wallet: any,
    _token: 'SOL' | 'USDC' = 'USDC',
  ): Promise<string> {
    const walletAddress = getWalletAddress(wallet);
    if (!walletAddress || !testMint.value || !hasKeys()) {
      throw new Error('Wallet not connected, mint not setup, or keys not derived');
    }

    loading.value = true;
    error.value = null;

    try {
      const connection = getConnection();
      const zkSdk = await loadZkSdk();
      const walletPubkey = new PublicKey(walletAddress);
      const mintPubkey = new PublicKey(testMint.value);
      const aeKey = getAeKey();

      const ata = getAssociatedTokenAddressSync(
        mintPubkey,
        walletPubkey,
        false,
        TOKEN_2022_PROGRAM_ID,
      );

      // Read current account state
      const accountInfo = await connection.getAccountInfo(ata);
      if (!accountInfo) {
        throw new Error('Token account not found');
      }

      // Get the pending balance credit counter
      const counter = readPendingBalanceCreditCounter(accountInfo.data);
      console.log('[CT] Pending balance credit counter:', counter.toString());

      // Read current available balance
      const decryptableBytes = readDecryptableAvailableBalance(accountInfo.data);
      let currentAvailable = 0n;
      if (decryptableBytes) {
        const ciphertext = zkSdk.AeCiphertext.fromBytes(decryptableBytes);
        if (ciphertext) {
          const decrypted = ciphertext.decrypt(aeKey);
          if (decrypted !== undefined) {
            currentAvailable = decrypted;
          }
        }
      }
      console.log('[CT] Current available balance:', currentAvailable.toString());

      // Read and decrypt pending balance
      const elGamal = getElGamalKeypair();
      const pendingCiphertexts = readPendingBalanceCiphertexts(accountInfo.data);
      let pendingAmount = 0n;
      if (pendingCiphertexts) {
        const loCiphertext = zkSdk.ElGamalCiphertext.fromBytes(pendingCiphertexts.lo);
        const hiCiphertext = zkSdk.ElGamalCiphertext.fromBytes(pendingCiphertexts.hi);
        if (loCiphertext && hiCiphertext) {
          const secretKey = elGamal.secret();
          const loAmount = secretKey.decrypt(loCiphertext);
          const hiAmount = secretKey.decrypt(hiCiphertext);
          pendingAmount = loAmount + (hiAmount << 16n);
        }
      }
      console.log('[CT] Pending amount:', pendingAmount.toString());

      // Calculate new available balance = current + pending
      const newAvailableBalance = currentAvailable + pendingAmount;
      console.log('[CT] New available balance:', newAvailableBalance.toString());

      // Encrypt the new balance for the decryptable_available_balance field
      const newDecryptableBalance = aeKey.encrypt(newAvailableBalance);
      const newDecryptableBytes = newDecryptableBalance.toBytes();

      const applyIx = createApplyPendingBalanceInstruction(
        ata,
        walletPubkey,
        counter,
        newDecryptableBytes,
      );

      const sig = await buildAndSendTransaction(
        connection,
        wallet as WalletAdapter,
        [applyIx],
        { description: 'apply pending balance' },
      );

      console.log('[CT] Applied pending balance, tx:', sig);
      return sig;
    } catch (e: any) {
      error.value = e.message || 'Failed to apply pending balance';
      throw e;
    } finally {
      loading.value = false;
    }
  }

  /**
   * Withdraw from confidential balance (private -> public)
   * This is the most complex operation requiring ZK proofs
   */
  async function withdrawFromConfidential(
    wallet: any,
    amount: number,
    _token: 'SOL' | 'USDC' = 'USDC',
  ): Promise<string> {
    const walletAddress = getWalletAddress(wallet);
    if (!walletAddress || !testMint.value || !hasKeys()) {
      throw new Error('Wallet not connected, mint not setup, or keys not derived');
    }

    loading.value = true;
    error.value = null;
    withdrawProgress.value = { step: 0, totalSteps: 6, currentStep: 'Preparing...' };

    try {
      const connection = getConnection();
      const zkSdk = await loadZkSdk();
      const walletPubkey = new PublicKey(walletAddress);
      const mintPubkey = new PublicKey(testMint.value);
      const elGamal = getElGamalKeypair();
      const aeKey = getAeKey();

      const ata = getAssociatedTokenAddressSync(
        mintPubkey,
        walletPubkey,
        false,
        TOKEN_2022_PROGRAM_ID,
      );

      const tokenAmount = BigInt(Math.floor(amount * Math.pow(10, DECIMALS)));

      // Step 1: Read current balance and generate proofs
      withdrawProgress.value = { step: 1, totalSteps: 6, currentStep: 'Generating ZK proofs...' };

      const accountInfo = await connection.getAccountInfo(ata);
      if (!accountInfo) {
        throw new Error('Token account not found');
      }

      // Get current available balance
      const decryptableBytes = readDecryptableAvailableBalance(accountInfo.data);
      let currentBalance = 0n;
      if (decryptableBytes) {
        const ciphertext = zkSdk.AeCiphertext.fromBytes(decryptableBytes);
        if (ciphertext) {
          const decrypted = ciphertext.decrypt(aeKey);
          if (decrypted !== undefined) {
            currentBalance = decrypted;
          }
        }
      }

      if (tokenAmount > currentBalance) {
        throw new Error(`Insufficient confidential balance. Have ${currentBalance}, need ${tokenAmount}`);
      }

      const newBalance = currentBalance - tokenAmount;
      console.log(`[CT] Withdrawing ${tokenAmount}, current: ${currentBalance}, new: ${newBalance}`);

      // Get current balance ciphertext for proof generation
      const currentCiphertextBytes = readAvailableBalanceCiphertext(accountInfo.data);
      if (!currentCiphertextBytes) {
        throw new Error('Could not read available balance ciphertext');
      }

      // Create ciphertext for withdraw amount using ElGamal
      const withdrawCiphertext = elGamal.pubkey().encryptU64(tokenAmount);
      const withdrawCiphertextBytes = withdrawCiphertext.toBytes();

      // Compute new balance ciphertext (homomorphic subtraction)
      const newBalanceCiphertextBytes = subtractCiphertexts(
        currentCiphertextBytes,
        withdrawCiphertextBytes,
      );

      const newBalanceCiphertext = zkSdk.ElGamalCiphertext.fromBytes(newBalanceCiphertextBytes);
      if (!newBalanceCiphertext) {
        throw new Error('Failed to parse new balance ciphertext');
      }

      // Generate equality proof
      const { PedersenOpening, PedersenCommitment, CiphertextCommitmentEqualityProofData, BatchedRangeProofU64Data } = zkSdk;

      const newBalanceOpening = new PedersenOpening();
      const newBalanceCommitment = PedersenCommitment.from(newBalance, newBalanceOpening);

      const equalityProof = new CiphertextCommitmentEqualityProofData(
        elGamal,
        newBalanceCiphertext,
        newBalanceCommitment,
        newBalanceOpening,
        newBalance,
      );
      const equalityProofBytes = equalityProof.toBytes();
      equalityProof.verify();
      console.log('[CT] Equality proof generated and verified');

      // Generate range proof (prove new balance >= 0 and <= 2^64)
      withdrawProgress.value = { step: 2, totalSteps: 6, currentStep: 'Creating proof accounts...' };

      const rangeProof = new BatchedRangeProofU64Data(
        [newBalanceCommitment],
        new BigUint64Array([newBalance]),
        new Uint8Array([64]),
        [newBalanceOpening],
      );
      const rangeProofBytes = rangeProof.toBytes();
      rangeProof.verify();
      console.log('[CT] Range proof generated and verified');

      // Step 2: Create context state accounts
      const equalityContextAccount = Keypair.generate();
      const rangeContextAccount = Keypair.generate();

      const equalityAccountSize = getContextStateAccountSize('equality');
      const rangeAccountSize = getContextStateAccountSize('range');

      const equalityRent = await connection.getMinimumBalanceForRentExemption(equalityAccountSize);
      const rangeRent = await connection.getMinimumBalanceForRentExemption(rangeAccountSize);

      // Create equality context account
      withdrawProgress.value = { step: 3, totalSteps: 6, currentStep: 'Creating equality context...' };

      const createEqualityCtxIx = SystemProgram.createAccount({
        fromPubkey: walletPubkey,
        newAccountPubkey: equalityContextAccount.publicKey,
        space: equalityAccountSize,
        lamports: equalityRent,
        programId: ZK_ELGAMAL_PROOF_PROGRAM_ID,
      });

      await signAndSendTransaction(
        connection,
        wallet as WalletAdapter,
        new Transaction().add(createEqualityCtxIx),
        {
          additionalSigners: [equalityContextAccount],
          skipPreflight: true,
          description: 'create equality context',
        },
      );

      // Verify equality proof
      withdrawProgress.value = { step: 4, totalSteps: 6, currentStep: 'Verifying equality proof...' };

      const verifyEqualityIx = createVerifyCiphertextCommitmentEqualityInstruction(
        equalityProofBytes,
        equalityContextAccount.publicKey,
        walletPubkey,
      );

      await buildAndSendTransaction(
        connection,
        wallet as WalletAdapter,
        [verifyEqualityIx],
        { skipPreflight: true, description: 'verify equality proof' },
      );

      // Create range context account
      withdrawProgress.value = { step: 5, totalSteps: 6, currentStep: 'Verifying range proof...' };

      const createRangeCtxIx = SystemProgram.createAccount({
        fromPubkey: walletPubkey,
        newAccountPubkey: rangeContextAccount.publicKey,
        space: rangeAccountSize,
        lamports: rangeRent,
        programId: ZK_ELGAMAL_PROOF_PROGRAM_ID,
      });

      await signAndSendTransaction(
        connection,
        wallet as WalletAdapter,
        new Transaction().add(createRangeCtxIx),
        {
          additionalSigners: [rangeContextAccount],
          skipPreflight: true,
          description: 'create range context',
        },
      );

      // Verify range proof
      const verifyRangeIx = createVerifyBatchedRangeProofU64Instruction(
        rangeProofBytes,
        rangeContextAccount.publicKey,
        walletPubkey,
      );

      await buildAndSendTransaction(
        connection,
        wallet as WalletAdapter,
        [verifyRangeIx],
        { skipPreflight: true, description: 'verify range proof' },
      );

      // Step 6: Execute withdrawal
      withdrawProgress.value = { step: 6, totalSteps: 6, currentStep: 'Executing withdrawal...' };

      // Encrypt new balance for storage
      const newDecryptableBalance = aeKey.encrypt(newBalance);
      const newDecryptableBytes = newDecryptableBalance.toBytes();

      const withdrawIx = createWithdrawInstruction(
        ata,
        mintPubkey,
        walletPubkey,
        tokenAmount,
        DECIMALS,
        newDecryptableBytes,
        equalityContextAccount.publicKey,
        rangeContextAccount.publicKey,
      );

      const sig = await buildAndSendTransaction(
        connection,
        wallet as WalletAdapter,
        [withdrawIx],
        { skipPreflight: true, description: 'execute withdrawal' },
      );

      console.log(`[CT] Withdrew ${amount} tokens from confidential, tx:`, sig);
      return sig;
    } catch (e: any) {
      error.value = e.message || 'Failed to withdraw';
      throw e;
    } finally {
      loading.value = false;
      withdrawProgress.value = null;
    }
  }

  /**
   * Transfer tokens confidentially to another address
   * This is a peer-to-peer confidential transfer requiring 3 proofs:
   * 1. Validity proof - proves grouped ciphertexts are valid
   * 2. Equality proof - proves new balance ciphertext matches commitment
   * 3. Range proof - proves all values are non-negative
   */
  async function transferConfidential(
    wallet: any,
    recipientAddress: string,
    amount: number,
    memo?: string,  // Optional memo (e.g., payment reference for invoices)
  ): Promise<string> {
    const walletAddress = getWalletAddress(wallet);
    if (!walletAddress || !testMint.value || !hasKeys()) {
      throw new Error('Wallet not connected, mint not setup, or keys not derived');
    }

    loading.value = true;
    error.value = null;
    withdrawProgress.value = { step: 0, totalSteps: 9, currentStep: 'Preparing transfer...' };

    try {
      const connection = getConnection();
      const zkSdk = await loadZkSdk();
      const walletPubkey = new PublicKey(walletAddress);
      const recipientPubkey = new PublicKey(recipientAddress);
      const mintPubkey = new PublicKey(testMint.value);
      const senderElGamal = getElGamalKeypair();
      const aeKey = getAeKey();

      // Get source ATA (sender)
      const sourceAta = getAssociatedTokenAddressSync(
        mintPubkey,
        walletPubkey,
        false,
        TOKEN_2022_PROGRAM_ID,
      );

      // Get destination ATA (recipient)
      const destAta = getAssociatedTokenAddressSync(
        mintPubkey,
        recipientPubkey,
        false,
        TOKEN_2022_PROGRAM_ID,
      );

      const tokenAmount = BigInt(Math.floor(amount * Math.pow(10, DECIMALS)));

      // Step 1: Read account data
      withdrawProgress.value = { step: 1, totalSteps: 9, currentStep: 'Reading accounts...' };

      const sourceAccountInfo = await connection.getAccountInfo(sourceAta);
      if (!sourceAccountInfo) {
        throw new Error('Source token account not found');
      }

      const destAccountInfo = await connection.getAccountInfo(destAta);
      if (!destAccountInfo) {
        console.error('[CT] Recipient ATA not found:', destAta.toBase58());
        console.error('[CT] Recipient wallet:', recipientPubkey.toBase58());
        console.error('[CT] Mint:', mintPubkey.toBase58());
        throw new Error('Recipient does not have a token account for this mint. They need to enable confidential transfers first.');
      }
      console.log('[CT] === RECIPIENT ACCOUNT DEBUG ===');
      console.log('[CT] Recipient ATA:', destAta.toBase58());
      console.log('[CT] Recipient wallet:', recipientPubkey.toBase58());
      console.log('[CT] Mint used:', mintPubkey.toBase58());
      console.log('[CT] Account data length:', destAccountInfo.data.length);
      console.log('[CT] Account owner program:', destAccountInfo.owner.toBase58());

      // Log first 200 bytes of account data for debugging
      const dataPreview = Array.from(destAccountInfo.data.slice(0, 200))
        .map(b => b.toString(16).padStart(2, '0'))
        .join(' ');
      console.log('[CT] Account data preview (first 200 bytes):', dataPreview);

      if (!hasConfidentialTransferExtension(destAccountInfo.data)) {
        console.error('[CT] Recipient account missing CT extension');
        console.error('[CT] Expected extension type 5 (ConfidentialTransferAccount)');
        console.error('[CT] Recipient should run "Enable Confidential Transfers" for mint:', mintPubkey.toBase58());
        throw new Error('Recipient account is not configured for confidential transfers. They need to click "Enable Confidential Transfers" first.');
      }

      // Read recipient's ElGamal public key
      const recipientElGamalPubkeyBytes = readElGamalPubkey(destAccountInfo.data);
      if (!recipientElGamalPubkeyBytes) {
        throw new Error('Could not read recipient ElGamal public key');
      }
      const recipientElGamalPubkey = zkSdk.ElGamalPubkey.fromBytes(recipientElGamalPubkeyBytes);
      if (!recipientElGamalPubkey) {
        throw new Error('Failed to parse recipient ElGamal public key');
      }

      // Get current available balance
      const decryptableBytes = readDecryptableAvailableBalance(sourceAccountInfo.data);
      let currentBalance = 0n;
      if (decryptableBytes) {
        const ciphertext = zkSdk.AeCiphertext.fromBytes(decryptableBytes);
        if (ciphertext) {
          const decrypted = ciphertext.decrypt(aeKey);
          if (decrypted !== undefined) {
            currentBalance = decrypted;
          }
        }
      }

      if (tokenAmount > currentBalance) {
        throw new Error(`Insufficient confidential balance. Have ${currentBalance}, need ${tokenAmount}`);
      }

      const newBalance = currentBalance - tokenAmount;
      console.log(`[CT] Transferring ${tokenAmount}, current: ${currentBalance}, new: ${newBalance}`);

      // Step 2: Generate validity proof for grouped ciphertexts
      withdrawProgress.value = { step: 2, totalSteps: 9, currentStep: 'Generating validity proof...' };

      const {
        PedersenOpening,
        PedersenCommitment,
        CiphertextCommitmentEqualityProofData,
        BatchedGroupedCiphertext3HandlesValidityProofData,
        BatchedRangeProofU128Data,
        GroupedElGamalCiphertext3Handles,
        ElGamalCiphertext,
      } = zkSdk;

      if (!BatchedGroupedCiphertext3HandlesValidityProofData || !BatchedRangeProofU128Data || !GroupedElGamalCiphertext3Handles) {
        throw new Error('Required proof types not available in ZK SDK');
      }

      // Split amount into lo (16 bits) and hi (32 bits)
      const amountLo = tokenAmount & BigInt(0xffff);
      const amountHi = tokenAmount >> BigInt(16);
      console.log(`[CT] Amount split: lo=${amountLo}, hi=${amountHi}`);

      const openingLo = new PedersenOpening();
      const openingHi = new PedersenOpening();

      // Get ElGamal pubkeys
      const senderElGamalPubkey = senderElGamal.pubkey();

      // Use hardcoded auditor pubkey (same one used when creating the mint)
      const auditorElGamalPubkey = zkSdk.ElGamalPubkey.fromBytes(AUDITOR_ELGAMAL_PUBKEY);
      if (!auditorElGamalPubkey) {
        throw new Error('Failed to parse auditor ElGamal pubkey');
      }
      console.log('[CT] Using hardcoded auditor pubkey for transfer');

      // Create grouped ciphertexts with 3 handles: source, destination, auditor
      const groupedCiphertextLo = GroupedElGamalCiphertext3Handles.encryptWith(
        senderElGamalPubkey,
        recipientElGamalPubkey,
        auditorElGamalPubkey,
        amountLo,
        openingLo,
      );

      const groupedCiphertextHi = GroupedElGamalCiphertext3Handles.encryptWith(
        senderElGamalPubkey,
        recipientElGamalPubkey,
        auditorElGamalPubkey,
        amountHi,
        openingHi,
      );

      const validityProof = new BatchedGroupedCiphertext3HandlesValidityProofData(
        senderElGamalPubkey,
        recipientElGamalPubkey,
        auditorElGamalPubkey,
        groupedCiphertextLo,
        groupedCiphertextHi,
        amountLo,
        amountHi,
        openingLo,
        openingHi,
      );

      const validityProofBytes = validityProof.toBytes();
      validityProof.verify();
      console.log('[CT] Validity proof generated');

      // Step 3: Prepare for equality proof
      withdrawProgress.value = { step: 3, totalSteps: 9, currentStep: 'Generating equality proof...' };

      // Read current balance ciphertext from account
      const currentBalanceCiphertextBytes = readAvailableBalanceCiphertext(sourceAccountInfo.data);
      if (!currentBalanceCiphertextBytes) {
        throw new Error('Could not read available balance ciphertext');
      }

      // Extract source ciphertexts from grouped ciphertexts
      const groupedLoBytes = groupedCiphertextLo.toBytes();
      const groupedHiBytes = groupedCiphertextHi.toBytes();
      const sourceCiphertextLoBytes = groupedLoBytes.slice(0, 64);
      const sourceCiphertextHiBytes = groupedHiBytes.slice(0, 64);

      // Combine lo + hi ciphertexts for transfer amount
      const transferAmountCiphertextBytes = combineLowHighCiphertexts(
        sourceCiphertextLoBytes,
        sourceCiphertextHiBytes,
        16,
      );

      // Compute new_balance = current_balance - transfer_amount (homomorphic)
      const newBalanceCiphertextBytes = subtractCiphertexts(
        currentBalanceCiphertextBytes,
        transferAmountCiphertextBytes,
      );

      const newBalanceCiphertext = ElGamalCiphertext.fromBytes(newBalanceCiphertextBytes);
      if (!newBalanceCiphertext) {
        throw new Error('Failed to parse new balance ciphertext');
      }

      // Create Pedersen commitment for new balance
      const newBalanceOpening = new PedersenOpening();
      const newBalanceCommitment = PedersenCommitment.from(newBalance, newBalanceOpening);

      // Generate equality proof
      const equalityProof = new CiphertextCommitmentEqualityProofData(
        senderElGamal,
        newBalanceCiphertext,
        newBalanceCommitment,
        newBalanceOpening,
        newBalance,
      );

      const equalityProofBytes = equalityProof.toBytes();
      equalityProof.verify();
      console.log('[CT] Equality proof generated');

      // Step 4: Generate range proof (U128)
      withdrawProgress.value = { step: 4, totalSteps: 9, currentStep: 'Generating range proof...' };

      // Create commitments for transfer_lo, transfer_hi, and padding
      const transferLoCommitment = PedersenCommitment.from(amountLo, openingLo);
      const transferHiCommitment = PedersenCommitment.from(amountHi, openingHi);
      const paddingOpening = new PedersenOpening();
      const paddingCommitment = PedersenCommitment.from(BigInt(0), paddingOpening);

      const amounts = new BigUint64Array([newBalance, amountLo, amountHi, BigInt(0)]);
      const bitLengths = new Uint8Array([64, 16, 32, 16]); // must sum to 128

      const rangeProof = new BatchedRangeProofU128Data(
        [newBalanceCommitment, transferLoCommitment, transferHiCommitment, paddingCommitment],
        amounts,
        bitLengths,
        [newBalanceOpening, openingLo, openingHi, paddingOpening],
      );

      const rangeProofBytes = rangeProof.toBytes();
      rangeProof.verify();
      console.log('[CT] Range proof generated');

      // Step 5: Create context state accounts
      withdrawProgress.value = { step: 5, totalSteps: 9, currentStep: 'Creating proof accounts...' };

      const equalityContextAccount = Keypair.generate();
      const validityContextAccount = Keypair.generate();
      const rangeContextAccount = Keypair.generate();

      const equalityAccountSize = getContextStateAccountSize('equality');
      const validityAccountSize = getContextStateAccountSize('validity');
      const rangeAccountSize = getContextStateAccountSize('range');

      const equalityRent = await connection.getMinimumBalanceForRentExemption(equalityAccountSize);
      const validityRent = await connection.getMinimumBalanceForRentExemption(validityAccountSize);
      const rangeRent = await connection.getMinimumBalanceForRentExemption(rangeAccountSize);

      // Create and verify equality proof
      withdrawProgress.value = { step: 6, totalSteps: 9, currentStep: 'Verifying equality proof...' };

      const createEqualityCtxIx = SystemProgram.createAccount({
        fromPubkey: walletPubkey,
        newAccountPubkey: equalityContextAccount.publicKey,
        space: equalityAccountSize,
        lamports: equalityRent,
        programId: ZK_ELGAMAL_PROOF_PROGRAM_ID,
      });

      await signAndSendTransaction(
        connection,
        wallet as WalletAdapter,
        new Transaction().add(createEqualityCtxIx),
        { additionalSigners: [equalityContextAccount], skipPreflight: true, description: 'create equality context' },
      );

      const verifyEqualityIx = createVerifyCiphertextCommitmentEqualityInstruction(
        equalityProofBytes,
        equalityContextAccount.publicKey,
        walletPubkey,
      );
      await buildAndSendTransaction(connection, wallet as WalletAdapter, [verifyEqualityIx], { skipPreflight: true, description: 'verify equality proof' });

      // Create and verify validity proof
      withdrawProgress.value = { step: 7, totalSteps: 9, currentStep: 'Verifying validity proof...' };

      const createValidityCtxIx = SystemProgram.createAccount({
        fromPubkey: walletPubkey,
        newAccountPubkey: validityContextAccount.publicKey,
        space: validityAccountSize,
        lamports: validityRent,
        programId: ZK_ELGAMAL_PROOF_PROGRAM_ID,
      });

      await signAndSendTransaction(
        connection,
        wallet as WalletAdapter,
        new Transaction().add(createValidityCtxIx),
        { additionalSigners: [validityContextAccount], skipPreflight: true, description: 'create validity context' },
      );

      const verifyValidityIx = createVerifyBatchedGroupedCiphertext3HandlesValidityInstruction(
        validityProofBytes,
        validityContextAccount.publicKey,
        walletPubkey,
      );
      await buildAndSendTransaction(connection, wallet as WalletAdapter, [verifyValidityIx], { skipPreflight: true, description: 'verify validity proof' });

      // Create and verify range proof
      withdrawProgress.value = { step: 8, totalSteps: 9, currentStep: 'Verifying range proof...' };

      const createRangeCtxIx = SystemProgram.createAccount({
        fromPubkey: walletPubkey,
        newAccountPubkey: rangeContextAccount.publicKey,
        space: rangeAccountSize,
        lamports: rangeRent,
        programId: ZK_ELGAMAL_PROOF_PROGRAM_ID,
      });

      await signAndSendTransaction(
        connection,
        wallet as WalletAdapter,
        new Transaction().add(createRangeCtxIx),
        { additionalSigners: [rangeContextAccount], skipPreflight: true, description: 'create range context' },
      );

      const verifyRangeIx = createVerifyBatchedRangeProofU128Instruction(
        rangeProofBytes,
        rangeContextAccount.publicKey,
        walletPubkey,
      );
      await buildAndSendTransaction(connection, wallet as WalletAdapter, [verifyRangeIx], { skipPreflight: true, description: 'verify range proof' });

      // Step 9: Execute the confidential transfer
      withdrawProgress.value = { step: 9, totalSteps: 9, currentStep: 'Executing transfer...' };

      // Encrypt new sender balance with AES
      const newSenderDecryptableBalance = aeKey.encrypt(newBalance);

      // Extract auditor ciphertext handles from grouped ciphertexts
      // Format: commitment (32) + first handle (32) + second handle (32) + third handle (32) = 128 bytes
      const auditorCiphertextLo = new Uint8Array(64);
      auditorCiphertextLo.set(groupedLoBytes.slice(0, 32), 0); // commitment
      auditorCiphertextLo.set(groupedLoBytes.slice(96, 128), 32); // auditor handle (third)

      const auditorCiphertextHi = new Uint8Array(64);
      auditorCiphertextHi.set(groupedHiBytes.slice(0, 32), 0); // commitment
      auditorCiphertextHi.set(groupedHiBytes.slice(96, 128), 32); // auditor handle (third)

      const transferIx = createConfidentialTransferInstruction(
        sourceAta,
        mintPubkey,
        destAta,
        equalityContextAccount.publicKey,
        validityContextAccount.publicKey,
        rangeContextAccount.publicKey,
        walletPubkey,
        newSenderDecryptableBalance.toBytes(),
        auditorCiphertextLo,
        auditorCiphertextHi,
      );

      // Build instructions array
      const instructions = [transferIx];

      // Add memo if provided (for invoice linking, payment references, etc.)
      if (memo) {
        const memoIx = createMemoInstruction(memo, [walletPubkey]);
        instructions.push(memoIx);
        console.log('[CT] Adding memo to transfer:', memo);
      }

      const sig = await buildAndSendTransaction(
        connection,
        wallet as WalletAdapter,
        instructions,
        { skipPreflight: true, description: 'execute confidential transfer' },
      );

      console.log(`[CT] Transferred ${amount} tokens confidentially, tx:`, sig);

      // Fetch and log full transaction details to verify memo
      try {
        // Wait a moment for transaction to be indexed
        await new Promise(resolve => setTimeout(resolve, 1000));
        const txDetails = await connection.getTransaction(sig, {
          maxSupportedTransactionVersion: 0,
          commitment: 'confirmed',
        });

        if (txDetails) {
          console.log('[CT] === TRANSACTION DETAILS ===');
          console.log('[CT] Signature:', sig);
          console.log('[CT] Slot:', txDetails.slot);
          console.log('[CT] Fee:', txDetails.meta?.fee, 'lamports');

          // Log all program logs
          console.log('[CT] Program Logs:');
          txDetails.meta?.logMessages?.forEach((log, i) => {
            console.log(`[CT]   ${i}: ${log}`);
          });

          // Check for memo specifically
          const memoLogs = txDetails.meta?.logMessages?.filter(log =>
            log.includes('Memo') || log.includes('MemoSq4g')
          );
          if (memoLogs && memoLogs.length > 0) {
            console.log('[CT] ✓ Memo found in transaction:');
            memoLogs.forEach(log => console.log('[CT]   ', log));
          } else if (memo) {
            console.log('[CT] ⚠ Memo was provided but not found in logs');
          }

          console.log('[CT] ==============================');
        }
      } catch (fetchErr) {
        console.log('[CT] Could not fetch transaction details:', fetchErr);
      }

      return sig;
    } catch (e: any) {
      error.value = e.message || 'Failed to transfer';
      throw e;
    } finally {
      loading.value = false;
      withdrawProgress.value = null;
    }
  }

  /**
   * Check if account is configured for confidential transfers
   */
  async function isAccountConfigured(wallet: any): Promise<boolean> {
    const walletAddress = getWalletAddress(wallet);
    if (!walletAddress || !testMint.value) return false;

    try {
      const connection = getConnection();
      const walletPubkey = new PublicKey(walletAddress);
      const mintPubkey = new PublicKey(testMint.value);

      const ata = getAssociatedTokenAddressSync(
        mintPubkey,
        walletPubkey,
        false,
        TOKEN_2022_PROGRAM_ID,
      );

      const accountInfo = await connection.getAccountInfo(ata);
      if (!accountInfo) return false;

      return hasConfidentialTransferExtension(accountInfo.data);
    } catch (e) {
      return false;
    }
  }

  /**
   * Check if a recipient has CT configured (can receive private transfers)
   */
  async function checkRecipientHasCT(recipientAddress: string): Promise<boolean> {
    if (!testMint.value) {
      console.log('[CT] No mint configured, cannot check recipient');
      return false;
    }

    try {
      const connection = getConnection();
      const recipientPubkey = new PublicKey(recipientAddress);
      const mintPubkey = new PublicKey(testMint.value);

      const ata = getAssociatedTokenAddressSync(
        mintPubkey,
        recipientPubkey,
        false,
        TOKEN_2022_PROGRAM_ID,
      );

      const accountInfo = await connection.getAccountInfo(ata);
      if (!accountInfo) {
        console.log('[CT] Recipient ATA does not exist');
        return false;
      }

      const hasCT = hasConfidentialTransferExtension(accountInfo.data);
      console.log('[CT] Recipient has CT extension:', hasCT);
      return hasCT;
    } catch (e) {
      console.error('[CT] Error checking recipient CT status:', e);
      return false;
    }
  }

  /**
   * Diagnostic function to check any wallet's CT account status
   * Useful for debugging transfer issues
   */
  async function debugCheckRecipientAccount(recipientAddress: string): Promise<void> {
    if (!testMint.value) {
      console.error('[CT DEBUG] No mint set up');
      return;
    }

    const connection = getConnection();
    const recipientPubkey = new PublicKey(recipientAddress);
    const mintPubkey = new PublicKey(testMint.value);

    const ata = getAssociatedTokenAddressSync(
      mintPubkey,
      recipientPubkey,
      false,
      TOKEN_2022_PROGRAM_ID,
    );

    console.log('[CT DEBUG] =====================================');
    console.log('[CT DEBUG] Checking recipient account');
    console.log('[CT DEBUG] Recipient wallet:', recipientAddress);
    console.log('[CT DEBUG] Mint:', testMint.value);
    console.log('[CT DEBUG] Computed ATA:', ata.toBase58());

    const accountInfo = await connection.getAccountInfo(ata);

    if (!accountInfo) {
      console.log('[CT DEBUG] ✗ ATA does not exist');
      console.log('[CT DEBUG] Recipient needs to: 1) Enable CT, 2) Unlock Private Balance');
      return;
    }

    console.log('[CT DEBUG] ✓ ATA exists');
    console.log('[CT DEBUG] Owner program:', accountInfo.owner.toBase58());
    console.log('[CT DEBUG] Expected owner:', TOKEN_2022_PROGRAM_ID.toBase58());
    console.log('[CT DEBUG] Owner matches:', accountInfo.owner.equals(TOKEN_2022_PROGRAM_ID));
    console.log('[CT DEBUG] Data length:', accountInfo.data.length);

    const hasCT = hasConfidentialTransferExtension(accountInfo.data);
    console.log('[CT DEBUG] Has CT extension:', hasCT ? '✓ YES' : '✗ NO');
    console.log('[CT DEBUG] =====================================');
  }

  /**
   * Fetch transaction history from the blockchain
   * Detects CT operations by analyzing token balance changes
   * Always fetches fresh from RPC - no local storage
   */
  async function fetchTransactionHistory(wallet: any): Promise<void> {
    const walletAddress = getWalletAddress(wallet);
    if (!walletAddress || !testMint.value) return;

    try {
      const connection = getConnection();
      const walletPubkey = new PublicKey(walletAddress);
      const mintPubkey = new PublicKey(testMint.value);

      const ata = getAssociatedTokenAddressSync(
        mintPubkey,
        walletPubkey,
        false,
        TOKEN_2022_PROGRAM_ID,
      );

      // Get recent transaction signatures for the token account
      const signatures = await connection.getSignaturesForAddress(ata, { limit: 30 });

      // Build fresh transaction list from RPC
      const freshTransactions: CTTransaction[] = [];
      const seenSignatures = new Set<string>();

      // Fetch and parse each transaction
      for (const sigInfo of signatures) {
        // Skip failed transactions or duplicates
        if (sigInfo.err) continue;
        if (seenSignatures.has(sigInfo.signature)) continue;
        seenSignatures.add(sigInfo.signature);

        try {
          const tx = await connection.getTransaction(sigInfo.signature, {
            maxSupportedTransactionVersion: 0,
          });

          if (!tx || !tx.meta) continue;

          // Find the token account index in the account keys
          const accountKeys = tx.transaction.message.staticAccountKeys ||
            (tx.transaction.message as any).accountKeys || [];
          const ataIndex = accountKeys.findIndex((key: PublicKey) => key.equals(ata));

          if (ataIndex === -1) continue;

          // Get pre and post token balances
          const preBalances = tx.meta.preTokenBalances || [];
          const postBalances = tx.meta.postTokenBalances || [];

          const preBalance = preBalances.find(b => b.accountIndex === ataIndex);
          const postBalance = postBalances.find(b => b.accountIndex === ataIndex);

          const prePubAmount = preBalance?.uiTokenAmount?.uiAmount || 0;
          const postPubAmount = postBalance?.uiTokenAmount?.uiAmount || 0;

          // Check log messages for CT operations
          const logs = tx.meta.logMessages || [];
          const logStr = logs.join(' ').toLowerCase();

          // Detect transaction type based on log messages (most reliable)
          let txType: CTTransaction['type'] | null = null;
          let amount = 0;

          // Skip mint transactions - they have "MintTo" in logs
          if (logStr.includes('mintto') || logStr.includes('mint_to')) {
            continue;
          }

          // Check for specific CT operations in logs
          if (logStr.includes('confidentialtransferdeposit') ||
              (logStr.includes('deposit') && !logStr.includes('withdraw'))) {
            txType = 'deposit';
            amount = prePubAmount - postPubAmount; // Public decreases on deposit
          } else if (logStr.includes('applypendingbalance') ||
                     logStr.includes('apply_pending')) {
            txType = 'apply';
            amount = 0; // Apply doesn't change public balance
          } else if (logStr.includes('confidentialtransferwithdraw') ||
                     (logStr.includes('withdraw') && logStr.includes('confidential'))) {
            txType = 'withdraw';
            amount = postPubAmount - prePubAmount; // Public increases on withdraw
          } else if (logStr.includes('confidentialtransfer') && !logStr.includes('mint')) {
            // Generic confidential transfer (could be peer-to-peer)
            txType = 'transfer';
            amount = 0; // Amount is encrypted
          } else if (prePubAmount > postPubAmount && Math.abs(prePubAmount - postPubAmount) > 0.0001) {
            // Public balance decreased without mint - likely a deposit
            txType = 'deposit';
            amount = prePubAmount - postPubAmount;
          }

          if (txType && (amount > 0 || txType === 'apply' || txType === 'transfer')) {
            freshTransactions.push({
              id: sigInfo.signature.slice(0, 16),
              type: txType,
              amount: Math.abs(amount),
              signature: sigInfo.signature,
              timestamp: sigInfo.blockTime ? sigInfo.blockTime * 1000 : Date.now(),
              status: 'success',
            });
          }
        } catch (txError) {
          console.debug('[CT] Failed to parse transaction:', sigInfo.signature.slice(0, 8));
        }
      }

      // Sort by timestamp (newest first) and update the ref
      freshTransactions.sort((a, b) => b.timestamp - a.timestamp);
      transactions.value = freshTransactions.slice(0, 50);

      console.log(`[CT] Fetched ${transactions.value.length} transactions from RPC`);
    } catch (e) {
      console.error('[CT] Failed to fetch transaction history:', e);
    }
  }

  // Clear error message
  function clearError(): void {
    error.value = null;
  }

  return {
    // State
    loading,
    error,
    elGamalPublicKey,
    testMint,
    withdrawProgress,
    transactions,

    // Functions
    deriveElGamalKeypair,
    setupTestMint,
    setupTokenAccount,
    configureConfidentialTransferAccount,
    mintTestTokens,
    getPublicBalance,
    getPendingBalance,
    getConfidentialBalance,
    depositToConfidential,
    applyPendingBalance,
    withdrawFromConfidential,
    transferConfidential,
    isAccountConfigured,
    checkRecipientHasCT,
    fetchTransactionHistory,
    clearTransactionHistory,
    clearError,
    debugCheckRecipientAccount,
  };
}
