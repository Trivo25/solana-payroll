{"noir_version":"1.0.0-beta.18+99bb8b5cf33d7669adbdef096b12d80f30b4c0c9","hash":"11423159637413741195","abi":{"parameters":[{"name":"preimage","type":{"kind":"array","length":256,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"payment_ref","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"}],"return_type":null,"error_types":{"361444214588792908":{"error_kind":"string","string":"attempt to multiply with overflow"},"1998584279744703196":{"error_kind":"string","string":"attempt to subtract with overflow"},"11019205087382408538":{"error_kind":"string","string":"Field failed to decompose into specified 4 limbs"},"14990209321349310352":{"error_kind":"string","string":"attempt to add with overflow"},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"},"16431471497789672479":{"error_kind":"string","string":"Index out of bounds"}}},"bytecode":"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","debug_symbols":"pZjRbts6DED/Jc99ECVKpPYrwzB0XTYUCNIiay9wMfTfr5joONuDgwvnpTxu4hOKEm3Zv3ff99/ef359Pv54+bX79Pn37tvp+XB4/vn18PL0+Pb8chz//b1L8aektvskDyPajD5jv0RJM8qMecYyo85YZ5w+mT6ZPpm+PH15+vL05eHLEcf5JaLN6DP2SyzjfI04fq9GbDPajH6JOj5vEduMNqPPOHw2Yk0zyox5xjLjGJ+P2MbnPWKMNwXEQCPzZoADMdYYjCVAgAwUIDwxMouzYmieAAEyUADS8Ao0wAAH+oSeAAEyEJ4oXG+AAQ6EZxRPU/y6BVSgAQY40Cecl9IZ4tc9IAMFCE8PGJ6cAoYnS8Csj+YECJCBAkSG+vHxsGPNf3077fex5P9ogtEar4+n/fFt9+n4fjg87P55PLyfv/Tr9fF4jm+Pp/HpSGR//D7iEP54PuyDPh6uZ6f1U6ukMs8eqIug/X9DjopcDFnLFoO6YaipbzJYvtNQc1oMuqkOZorBervT4CltMyyz6ZK3GLzIYtAtObRcyaHlVjflYHXJwbZUsqXMemipbJrN3pc69N431SGlpQ6l3D0K32SwJYfkW+aiSXIMkmWbQa+GvMnQllFIk21zIctciG4yiN83m1YZhLXrmq7y1/kx4aspXKtgq4shl3WBK8vJ++payLouGPctUtC8vpxyvTGIXknC0vr95pbCrHN5ME+ySeHLddK8p22K0heF3a/YmEVdbnxWu9+rGNeLuxVim5ZWqUyqlvXr7a3l3RNJjDW2Jig3hiEy7ldTITKeIVYl7UaTtcakelvfBtzOoyybkcF1dWUUv5FHT7Z0+/q27JaiX/eGXUTuVuS0UbHMq6xfeTXf2qL6srnLf8yJ+N+KG4ur2fVebOpritsD6ctActpyI3TXZUp97RZy6/y2dv6XcfT49Hz6+xk8xzNaHos9xzPaGeIZ7QICZKAAClSgAQZg7tNcUgIEyEABFBjmEo+l8WR3AQMc6BPiye4CAmSgAApgFsyCWTAL5ow5nvWKzhcGFyiAAhVogAEO9AmFahSqUahGoRqFapQKNMAAB6izYlbMilkxK2bFrJiVaijVUKpRqUalzpU6V+pcqXOlzpU6V8wVc8XcMDfMDXOjzo2cGzk3cm5Uo1GNRjWMahjVMKphVMMwG2bDbJgNs2F2zE7OTs5ONZxqONVwquFUw6mGU41ONTrmjrlj7pg75o65s+rowUIPKj2o9KDSg0oPKj14frtygQYY4ABmwSyYBbNgFsz0oNKDSg8qPaj0oNKD5/ctF8hAARTAnDFnzBlzxlwwl9ndGj0YezaNHryAAhUYZj1/2QAH+oTowQsIkIECKFABzIpZMSvmirlirpgr5oq5Yq6YK+aKuWJumBvmhrlhbpgb5oa5YW6YG2bDbJgNs2E2zIbZMBtmw2yYHbNjdsyOOXpQ471f9OAFGmCAA31C9OAFBMhAATB3zB1zx9wx92muKQECZKAAClSgAQY4gFkwC2bBLJgFs5zNH7GZOD0/fjvsY0cQe4b34xMbhHH49u8rn/Aa//X08rT//n7ax2bi+i5//Pk81vLDWCRfxjVnHI3NxMO47Y8jOX+Y7WF0WBxKHI5d9midLx+xO/kP","file_map":{"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        __assert_max_bit_size(self, BIT_SIZE);\n    }\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting array will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = __to_le_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting array will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = __to_be_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_le_radix(self, radix)\n    }\n\n    fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_be_radix(self, radix)\n    }\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(apply_range_constraint)]\nfn __assert_max_bit_size(value: Field, bit_size: u32) {}\n\n// `_radix` must be less than 256\n#[builtin(to_le_radix)]\nfn __to_le_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n// `_radix` must be less than 256\n#[builtin(to_be_radix)]\nfn __to_be_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n/// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting array will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_le_bits)]\nfn __to_le_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n/// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting array will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_be_bits)]\nfn __to_be_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime, static_assert};\n    use super::{\n        field_less_than, modulus_be_bits, modulus_be_bytes, modulus_le_bits, modulus_le_bytes,\n    };\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(\"radix must be greater than 1\");\n        }\n    }\n\n    // Updated test to account for Brillig restriction that radix must be greater than 2\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_brillig_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 1;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(\"radix must be greater than 1\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(\"radix must be less than or equal to 256\")\n        }\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    unconstrained fn not_enough_limbs_brillig() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    fn not_enough_limbs() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n\n    #[test]\n    unconstrained fn test_large_field_values_unconstrained() {\n        let large_field = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_field.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_field.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_field);\n\n        let radix_bytes: [u8; 8] = large_field.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_field);\n    }\n\n    #[test]\n    fn test_large_field_values() {\n        let large_val = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_val.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_val.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_val);\n\n        let radix_bytes: [u8; 8] = large_val.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_val);\n    }\n\n    #[test]\n    fn test_decomposition_edge_cases() {\n        let zero_bits: [u1; 8] = 0.to_le_bits();\n        assert_eq(zero_bits, [0; 8]);\n\n        let zero_bytes: [u8; 8] = 0.to_le_bytes();\n        assert_eq(zero_bytes, [0; 8]);\n\n        let one_bits: [u1; 8] = 1.to_le_bits();\n        let expected: [u1; 8] = [1, 0, 0, 0, 0, 0, 0, 0];\n        assert_eq(one_bits, expected);\n\n        let pow2_bits: [u1; 8] = 4.to_le_bits();\n        let expected: [u1; 8] = [0, 0, 1, 0, 0, 0, 0, 0];\n        assert_eq(pow2_bits, expected);\n    }\n\n    #[test]\n    fn test_pow_32() {\n        assert_eq(2.pow_32(3), 8);\n        assert_eq(3.pow_32(2), 9);\n        assert_eq(5.pow_32(0), 1);\n        assert_eq(7.pow_32(1), 7);\n\n        assert_eq(2.pow_32(10), 1024);\n\n        assert_eq(0.pow_32(5), 0);\n        assert_eq(0.pow_32(0), 1);\n\n        assert_eq(1.pow_32(100), 1);\n    }\n\n    #[test]\n    fn test_sgn0() {\n        assert_eq(0.sgn0(), 0);\n        assert_eq(2.sgn0(), 0);\n        assert_eq(4.sgn0(), 0);\n        assert_eq(100.sgn0(), 0);\n\n        assert_eq(1.sgn0(), 1);\n        assert_eq(3.sgn0(), 1);\n        assert_eq(5.sgn0(), 1);\n        assert_eq(101.sgn0(), 1);\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 8 limbs\")]\n    fn test_bit_decomposition_overflow() {\n        // 8 bits can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u1; 8] = large_val.to_le_bits();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 4 limbs\")]\n    fn test_byte_decomposition_overflow() {\n        // 4 bytes can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u8; 4] = large_val.to_le_bytes();\n    }\n\n    #[test]\n    fn test_to_from_be_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 BE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_minus_1_bytes[32 - 1] > 0);\n            p_minus_1_bytes[32 - 1] -= 1;\n\n            let p_minus_1 = Field::from_be_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_be_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 BE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_plus_1_bytes[32 - 1] < 255);\n            p_plus_1_bytes[32 - 1] += 1;\n\n            let p_plus_1 = Field::from_be_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 BE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_be_bytes();\n            assert_eq(p_plus_1_converted_bytes[32 - 1], 1);\n            p_plus_1_converted_bytes[32 - 1] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_be_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_be_bytes().len(), 32);\n            let p = Field::from_be_bytes::<32>(modulus_be_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 BE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_be_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 LE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_minus_1_bytes[0] > 0);\n            p_minus_1_bytes[0] -= 1;\n\n            let p_minus_1 = Field::from_le_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_le_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 LE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_plus_1_bytes[0] < 255);\n            p_plus_1_bytes[0] += 1;\n\n            let p_plus_1 = Field::from_le_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 LE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_le_bytes();\n            assert_eq(p_plus_1_converted_bytes[0], 1);\n            p_plus_1_converted_bytes[0] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_le_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_le_bytes().len(), 32);\n            let p = Field::from_le_bytes::<32>(modulus_le_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 LE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_le_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    /// Convert a little endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_le_bits<let N: u32>(bits: [u1; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bits().len(),\n            \"N must be less than or equal to modulus_le_bits().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    /// Convert a big endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_be_bits<let N: u32>(bits: [u1; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[N - 1 - i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    #[test]\n    fn test_to_from_be_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 BE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_minus_1_bits[254 - 1] > 0);\n            p_minus_1_bits[254 - 1] -= 1;\n\n            let p_minus_1 = from_be_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_be_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 BE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_plus_4_bits[254 - 3] < 1);\n            p_plus_4_bits[254 - 3] += 1;\n\n            let p_plus_4 = from_be_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 BE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_be_bits();\n            assert_eq(p_plus_4_converted_bits[254 - 3], 1);\n            p_plus_4_converted_bits[254 - 3] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_be_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_be_bits().len(), 254);\n            let p = from_be_bits::<254>(modulus_be_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 BE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_be_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 LE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_minus_1_bits[0] > 0);\n            p_minus_1_bits[0] -= 1;\n\n            let p_minus_1 = from_le_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_le_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 LE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_plus_4_bits[2] < 1);\n            p_plus_4_bits[2] += 1;\n\n            let p_plus_4 = from_le_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 LE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_le_bits();\n            assert_eq(p_plus_4_converted_bits[2], 1);\n            p_plus_4_converted_bits[2] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_le_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_le_bits().len(), 254);\n            let p = from_le_bits::<254>(modulus_le_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 LE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_le_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n}\n","path":"std/field/mod.nr"},"51":{"source":"use sha256::digest;\n\n// Invoice Payment Proof v1 - Simple Preimage Proof\n//\n// Proves: \"I know a preimage that hashes to payment_ref\"\n// This is the foundation for invoice payment proofs.\n//\n// The TypeScript side computes:\n// preimage = \"${invoiceId}:${sender}:${recipient}:${amount}:${nonce}\"\n// payment_ref = SHA256(preimage)\n\n// Maximum preimage length we support (256 bytes should be plenty)\nglobal MAX_PREIMAGE_LEN: u32 = 256;\n\nfn main(\n    // Private inputs (only prover knows)\n    preimage: [u8; MAX_PREIMAGE_LEN],  // The full preimage string as bytes (padded)\n\n    // Public inputs (verifier sees)\n    payment_ref: pub [u8; 32],          // SHA256 hash (32 bytes)\n) {\n    // Compute SHA256 of the preimage\n    let computed_hash: [u8; 32] = digest(preimage);\n\n    // Verify computed hash matches the public payment_ref\n    for i in 0..32 {\n        assert(computed_hash[i] == payment_ref[i]);\n    }\n}\n\n#[test]\nfn test_empty_preimage() {\n    // Test with empty preimage (all zeros)\n    let preimage: [u8; MAX_PREIMAGE_LEN] = [0; MAX_PREIMAGE_LEN];\n\n    // SHA256 of 256 zero bytes - computed externally\n    // For now, skip test\n}\n","path":"/Users/trivo/Documents/GitHub/solana-payroll/packages/app/circuits/zk_receipts/src/main.nr"},"60":{"source":"use std::hash::sha256_compression;\nuse std::runtime::is_unconstrained;\n\nuse constants::{\n    BLOCK_BYTE_PTR, BLOCK_SIZE, HASH, INITIAL_STATE, INT_BLOCK_SIZE, INT_SIZE, INT_SIZE_PTR,\n    MSG_BLOCK, MSG_SIZE_PTR, STATE, TWO_POW_16, TWO_POW_24, TWO_POW_32, TWO_POW_8,\n};\n\npub(crate) mod constants;\nmod tests;\nmod oracle_tests;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u32) -> HASH {\n    assert(message_size <= N);\n\n    let (h, msg_block) = process_full_blocks(msg, message_size, INITIAL_STATE);\n\n    finalize_sha256_blocks(message_size, h, msg_block)\n}\n\n/// Returns the first partially filled message block along with the internal state prior to its compression.\npub(crate) fn process_full_blocks<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    initial_state: STATE,\n) -> (STATE, MSG_BLOCK) {\n    if std::runtime::is_unconstrained() {\n        let num_full_blocks = message_size / BLOCK_SIZE;\n        // Intermediate hash, starting with the canonical initial value\n        let mut h: STATE = initial_state;\n        // Pointer into msg_block on a 64 byte scale\n        for i in 0..num_full_blocks {\n            let msg_block = build_msg_block(msg, message_size, BLOCK_SIZE * i);\n            h = sha256_compression(msg_block, h);\n        }\n\n        // We now build the final un-filled block.\n        let msg_byte_ptr = message_size % BLOCK_SIZE;\n        let msg_block: MSG_BLOCK = if msg_byte_ptr != 0 {\n            let num_full_blocks = message_size / BLOCK_SIZE;\n            let msg_start = BLOCK_SIZE * num_full_blocks;\n            build_msg_block(msg, message_size, msg_start)\n        } else {\n            // If the message size is a multiple of the block size (i.e. `msg_byte_ptr == 0`) then this block will be empty,\n            // so we short-circuit in this case.\n            [0; 16]\n        };\n\n        (h, msg_block)\n    } else {\n        let num_blocks = N / BLOCK_SIZE;\n\n        // We store the intermediate hash states and message blocks in these two arrays which allows us to select the correct state\n        // for the given message size with a lookup.\n        //\n        // These can be reasoned about as followed:\n        // Consider a message with an unknown number of bytes, `msg_size. It can be seen that this will have `msg_size / BLOCK_SIZE` full blocks.\n        // - `states[i]` should then be the state after processing the first `i` blocks.\n        // - `blocks[i]` should then be the next message block after processing the first `i` blocks.\n        // blocks[first_partially_filled_block_index] is the last block that is partially filled or all 0 if the message is a multiple of the block size.\n        //\n        // In other words:\n        //\n        // blocks = [block 1, block 2, ..., block N / BLOCK_SIZE, block N / BLOCK_SIZE + 1]\n        // states = [INITIAL_STATE, state after block 1, state after block 2, ..., state after block N / BLOCK_SIZE]\n        //\n        // We place the initial state in `states[0]` as in the case where the `message_size < BLOCK_SIZE` then there are no full blocks to process and no compressions should occur.\n        let mut blocks: [MSG_BLOCK; N / BLOCK_SIZE + 1] = std::mem::zeroed();\n        let mut states: [STATE; N / BLOCK_SIZE + 1] = [initial_state; N / BLOCK_SIZE + 1];\n\n        // Optimization for small messages. If the largest possible message is smaller than a block then we know that the first block is partially filled\n        // no matter the value of `message_size`.\n        //\n        // Note that the condition `N >= BLOCK_SIZE` is known during monomorphization so this has no runtime cost.\n        let first_partially_filled_block_index = if N >= BLOCK_SIZE {\n            message_size / BLOCK_SIZE\n        } else {\n            0\n        };\n\n        for i in 0..num_blocks {\n            let msg_start = BLOCK_SIZE * i;\n            let new_msg_block = build_msg_block(msg, message_size, msg_start);\n\n            blocks[i] = new_msg_block;\n            states[i + 1] = sha256_compression(new_msg_block, states[i]);\n        }\n        // If message_size/BLOCK_SIZE == N/BLOCK_SIZE, and there is a remainder, we need to process the last block.\n        if N % BLOCK_SIZE != 0 {\n            let new_msg_block = build_msg_block(msg, message_size, BLOCK_SIZE * num_blocks);\n\n            blocks[num_blocks] = new_msg_block;\n        }\n\n        (states[first_partially_filled_block_index], blocks[first_partially_filled_block_index])\n    }\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start` and pack them into a `MSG_BLOCK`.\npub(crate) unconstrained fn build_msg_block_helper<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> MSG_BLOCK {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if message_size < msg_start {\n        // This function is sometimes called with `msg_start` past the end of the message.\n        // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n        0\n    } else if message_size < msg_start + BLOCK_SIZE {\n        message_size - msg_start\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let int_input = (block_input + INT_SIZE - 1) / INT_SIZE;\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = (msg_item << 8) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    msg_block\n}\n\n// Build a message block from the input message starting at `msg_start`.\n//\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn build_msg_block<let N: u32>(msg: [u8; N], message_size: u32, msg_start: u32) -> MSG_BLOCK {\n    let msg_block =\n        // Safety: We constrain the block below by reconstructing each `u32` word from the input bytes.\n        unsafe { build_msg_block_helper(msg, message_size, msg_start) };\n\n    if !is_unconstrained() {\n        let mut msg_end = msg_start + BLOCK_SIZE;\n\n        let max_read_index = std::cmp::min(message_size, msg_end);\n\n        // Reconstructed packed item\n        let mut msg_item: Field = 0;\n\n        // Inclusive at the end so that we can compare the last item.\n        for k in msg_start..=msg_end {\n            if (k != msg_start) & (k % INT_SIZE == 0) {\n                // If we consumed some input we can compare against the block.\n                let msg_block_index = (k - msg_start) / INT_SIZE - 1;\n                assert_eq(msg_block[msg_block_index] as Field, msg_item);\n\n                msg_item = 0;\n            }\n\n            // If we have input to consume, add it at the rightmost position.\n            let msg_byte = if k < max_read_index { msg[k] } else { 0 };\n            msg_item = msg_item * (TWO_POW_8 as Field) + msg_byte as Field;\n        }\n    }\n    msg_block\n}\n\n// Encode `8 * message_size` into two `u32` limbs.\nunconstrained fn encode_len(message_size: u32) -> (u32, u32) {\n    let len = 8 * message_size as u64;\n    let lo = len & 0xFFFFFFFF;\n    let hi = (len >> 32) & 0xFFFFFFFF;\n    (lo as u32, hi as u32)\n}\n\n// Write the length into the last 8 bytes of the block.\nfn attach_len_to_msg_block(mut msg_block: MSG_BLOCK, message_size: u32) -> MSG_BLOCK {\n    // Safety: We assert the correctness of the decomposition below.\n    // 2 `u32` limbs cannot overflow the field modulus so performing the check as `Field`s is safe.\n    let (lo, hi) = unsafe { encode_len(message_size) };\n    assert_eq(8 * (message_size as Field), lo as Field + hi as Field * TWO_POW_32);\n\n    msg_block[INT_SIZE_PTR] = hi;\n    msg_block[INT_SIZE_PTR + 1] = lo;\n    msg_block\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\n/// Lookup table for the position of the padding bit within one of the `u32` words in the final message block.\nglobal PADDING_BIT_TABLE: [u32; 4] =\n    [(1 << 7) * TWO_POW_24, (1 << 7) * TWO_POW_16, (1 << 7) * TWO_POW_8, (1 << 7)];\n\n/// Add 1 bit padding to end of message and compress the block if there's not enough room for the 8-byte length.\n/// Returns the updated hash state and message block that will be used to write the message size.\n///\n/// # Assumptions:\n///\n/// - `msg_block[i] == 0` for all `i > msg_byte_ptr / INT_SIZE`\n/// - `msg_block[msg_byte_ptr / INT_SIZE] & ((1 << 7) * (msg_byte_ptr % INT_SIZE)) == 0`\nfn add_padding_byte_and_compress_if_needed(\n    mut msg_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    h: STATE,\n) -> (STATE, MSG_BLOCK) {\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    let index = msg_byte_ptr / INT_SIZE;\n\n    // Lookup the position of the padding bit and insert it into the message block.\n    msg_block[index] += PADDING_BIT_TABLE[msg_byte_ptr % INT_SIZE];\n\n    // If we don't have room to write the size, compress the block and reset it.\n    if msg_byte_ptr >= MSG_SIZE_PTR {\n        let h = sha256_compression(msg_block, h);\n\n        // In this case, the final block consists of all zeros with the last 8 bytes containing the length.\n        // We set msg_block to all zeros and attach_len_to_msg_block will add the length to the last 8 bytes.\n        let msg_block = [0; INT_BLOCK_SIZE];\n        (h, msg_block)\n    } else {\n        (h, msg_block)\n    }\n}\n\npub(crate) fn finalize_sha256_blocks(\n    message_size: u32,\n    mut h: STATE,\n    mut msg_block: MSG_BLOCK,\n) -> HASH {\n    let msg_byte_ptr = message_size % BLOCK_SIZE;\n\n    let (h, mut msg_block) = add_padding_byte_and_compress_if_needed(msg_block, msg_byte_ptr, h);\n\n    msg_block = attach_len_to_msg_block(msg_block, message_size);\n\n    hash_final_block(msg_block, h)\n}\n\n/**\n * Given some state of a partially computed sha256 hash and part of the preimage, continue hashing\n * @notice used for complex/ recursive offloading of post-partial hashing\n *\n * @param N - the maximum length of the message to hash\n * @param h - the intermediate hash state\n * @param msg - the preimage to hash\n * @param message_size - the actual length of the preimage to hash\n * @return the intermediate hash state after compressing in msg to h\n */\npub fn partial_sha256_var_interstitial<let N: u32>(\n    mut h: [u32; 8],\n    msg: [u8; N],\n    message_size: u32,\n) -> [u32; 8] {\n    assert(message_size % BLOCK_SIZE == 0, \"Message size must be a multiple of the block size\");\n    if std::runtime::is_unconstrained() {\n        // Safety: running as an unconstrained function\n        unsafe {\n            __sha_partial_var_interstitial(h, msg, message_size)\n        }\n    } else {\n        let (h, _) = process_full_blocks(msg, message_size, h);\n\n        h\n    }\n}\n\n/**\n * Given some state of a partially computed sha256 hash and remaining preimage, complete the hash\n * @notice used for traditional partial hashing\n *\n * @param N - the maximum length of the message to hash\n * @param h - the intermediate hash state\n * @param msg - the remaining preimage to hash\n * @param message_size - the size of the current chunk\n * @param real_message_size - the total size of the original preimage\n * @return finalized sha256 hash\n */\npub fn partial_sha256_var_end<let N: u32>(\n    mut h: [u32; 8],\n    msg: [u8; N],\n    message_size: u32,\n    real_message_size: u32,\n) -> [u8; 32] {\n    assert(message_size % BLOCK_SIZE == 0, \"Message size must be a multiple of the block size\");\n    if std::runtime::is_unconstrained() {\n        // Safety: running as an unconstrained function\n        unsafe {\n            h = __sha_partial_var_interstitial(h, msg, message_size);\n\n            // Handle setup of the final msg block.\n            // This case is only hit if the msg is less than the block size,\n            // or our message cannot be evenly split into blocks.\n\n            finalize_last_sha256_block(h, real_message_size, msg)\n        }\n    } else {\n        let (h, msg_block) = process_full_blocks(msg, message_size, h);\n        finalize_sha256_blocks(real_message_size, h, msg_block)\n    }\n}\n\nunconstrained fn __sha_partial_var_interstitial<let N: u32>(\n    mut h: [u32; 8],\n    msg: [u8; N],\n    message_size: u32,\n) -> [u32; 8] {\n    let num_full_blocks = message_size / BLOCK_SIZE;\n    // Intermediate hash, starting with the canonical initial value\n    // Pointer into msg_block on a 64 byte scale\n    for i in 0..num_full_blocks {\n        let msg_block = build_msg_block(msg, message_size, BLOCK_SIZE * i);\n        h = sha256_compression(msg_block, h);\n    }\n    h\n}\n\n// Helper function to finalize the message block with padding and length\nunconstrained fn finalize_last_sha256_block<let N: u32>(\n    mut h: STATE,\n    message_size: u32,\n    msg: [u8; N],\n) -> HASH {\n    let msg_byte_ptr = message_size % BLOCK_SIZE;\n\n    // We now build the final un-filled block.\n    let msg_block: MSG_BLOCK = if msg_byte_ptr != 0 {\n        let num_full_blocks = message_size / BLOCK_SIZE;\n        let msg_start = BLOCK_SIZE * num_full_blocks;\n        build_msg_block(msg, message_size, msg_start)\n    } else {\n        // If the message size is a multiple of the block size (i.e. `msg_byte_ptr == 0`) then this block will be empty,\n        // so we short-circuit in this case.\n        [0; 16]\n    };\n\n    // Once built, we need to add the necessary padding bytes and encoded length\n    let (h, mut msg_block) = add_padding_byte_and_compress_if_needed(msg_block, msg_byte_ptr, h);\n    msg_block = attach_len_to_msg_block(msg_block, message_size);\n\n    hash_final_block(msg_block, h)\n}\n\nmod test_process_full_blocks {\n\n    /// Wrapper to force an unconstrained runtime on process_full_blocks.\n    unconstrained fn unconstrained_process_full_blocks<let N: u32>(\n        msg: [u8; N],\n        message_size: u32,\n        h: super::STATE,\n    ) -> (super::STATE, super::MSG_BLOCK) {\n        super::process_full_blocks(msg, message_size, h)\n    }\n\n    #[test]\n    fn test_implementations_agree(msg: [u8; 100], message_size: u32) {\n        let message_size = message_size % 100;\n        // Safety: test function\n        let unconstrained_state =\n            unsafe { unconstrained_process_full_blocks(msg, message_size, super::INITIAL_STATE) };\n        let state = super::process_full_blocks(msg, message_size, super::INITIAL_STATE);\n        assert_eq(state, unconstrained_state);\n    }\n}\n\nmod test_sha256_var {\n\n    /// Wrapper to force an unconstrained runtime on sha256.\n    unconstrained fn unconstrained_sha256<let N: u32>(\n        msg: [u8; N],\n        message_size: u32,\n    ) -> super::HASH {\n        super::sha256_var(msg, message_size)\n    }\n\n    #[test]\n    fn test_implementations_agree(msg: [u8; 100], message_size: u32) {\n        let message_size = message_size % 100;\n        // Safety: test function\n        let unconstrained_sha = unsafe { unconstrained_sha256(msg, message_size) };\n        let sha = super::sha256_var(msg, message_size);\n        assert_eq(sha, unconstrained_sha);\n    }\n\n}\n","path":"/Users/trivo/nargo/github.com/noir-lang/sha256/v0.3.0/src/sha256.nr"}},"expression_width":{"Bounded":{"width":4}}}