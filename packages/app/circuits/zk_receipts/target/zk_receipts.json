{"noir_version":"1.0.0-beta.18+99bb8b5cf33d7669adbdef096b12d80f30b4c0c9","hash":"14890516691654239596","abi":{"parameters":[{"name":"invoice_id","type":{"kind":"array","length":36,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"sender","type":{"kind":"array","length":44,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"recipient","type":{"kind":"array","length":44,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"private"},{"name":"nonce","type":{"kind":"array","length":64,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"payment_ref","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},{"name":"public_invoice_id","type":{"kind":"array","length":36,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},{"name":"public_recipient","type":{"kind":"array","length":44,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},{"name":"min_amount","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"public"},{"name":"max_amount","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"public"}],"return_type":null,"error_types":{"361444214588792908":{"error_kind":"string","string":"attempt to multiply with overflow"},"1998584279744703196":{"error_kind":"string","string":"attempt to subtract with overflow"},"11019205087382408538":{"error_kind":"string","string":"Field failed to decompose into specified 4 limbs"},"14990209321349310352":{"error_kind":"string","string":"attempt to add with overflow"},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"},"16431471497789672479":{"error_kind":"string","string":"Index out of bounds"}}},"bytecode":"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","debug_symbols":"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","file_map":{"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        __assert_max_bit_size(self, BIT_SIZE);\n    }\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting array will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = __to_le_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting array will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = __to_be_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_le_radix(self, radix)\n    }\n\n    fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_be_radix(self, radix)\n    }\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(apply_range_constraint)]\nfn __assert_max_bit_size(value: Field, bit_size: u32) {}\n\n// `_radix` must be less than 256\n#[builtin(to_le_radix)]\nfn __to_le_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n// `_radix` must be less than 256\n#[builtin(to_be_radix)]\nfn __to_be_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n/// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting array will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_le_bits)]\nfn __to_le_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n/// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting array will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_be_bits)]\nfn __to_be_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime, static_assert};\n    use super::{\n        field_less_than, modulus_be_bits, modulus_be_bytes, modulus_le_bits, modulus_le_bytes,\n    };\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(\"radix must be greater than 1\");\n        }\n    }\n\n    // Updated test to account for Brillig restriction that radix must be greater than 2\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_brillig_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 1;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(\"radix must be greater than 1\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(\"radix must be less than or equal to 256\")\n        }\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    unconstrained fn not_enough_limbs_brillig() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    fn not_enough_limbs() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n\n    #[test]\n    unconstrained fn test_large_field_values_unconstrained() {\n        let large_field = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_field.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_field.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_field);\n\n        let radix_bytes: [u8; 8] = large_field.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_field);\n    }\n\n    #[test]\n    fn test_large_field_values() {\n        let large_val = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_val.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_val.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_val);\n\n        let radix_bytes: [u8; 8] = large_val.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_val);\n    }\n\n    #[test]\n    fn test_decomposition_edge_cases() {\n        let zero_bits: [u1; 8] = 0.to_le_bits();\n        assert_eq(zero_bits, [0; 8]);\n\n        let zero_bytes: [u8; 8] = 0.to_le_bytes();\n        assert_eq(zero_bytes, [0; 8]);\n\n        let one_bits: [u1; 8] = 1.to_le_bits();\n        let expected: [u1; 8] = [1, 0, 0, 0, 0, 0, 0, 0];\n        assert_eq(one_bits, expected);\n\n        let pow2_bits: [u1; 8] = 4.to_le_bits();\n        let expected: [u1; 8] = [0, 0, 1, 0, 0, 0, 0, 0];\n        assert_eq(pow2_bits, expected);\n    }\n\n    #[test]\n    fn test_pow_32() {\n        assert_eq(2.pow_32(3), 8);\n        assert_eq(3.pow_32(2), 9);\n        assert_eq(5.pow_32(0), 1);\n        assert_eq(7.pow_32(1), 7);\n\n        assert_eq(2.pow_32(10), 1024);\n\n        assert_eq(0.pow_32(5), 0);\n        assert_eq(0.pow_32(0), 1);\n\n        assert_eq(1.pow_32(100), 1);\n    }\n\n    #[test]\n    fn test_sgn0() {\n        assert_eq(0.sgn0(), 0);\n        assert_eq(2.sgn0(), 0);\n        assert_eq(4.sgn0(), 0);\n        assert_eq(100.sgn0(), 0);\n\n        assert_eq(1.sgn0(), 1);\n        assert_eq(3.sgn0(), 1);\n        assert_eq(5.sgn0(), 1);\n        assert_eq(101.sgn0(), 1);\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 8 limbs\")]\n    fn test_bit_decomposition_overflow() {\n        // 8 bits can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u1; 8] = large_val.to_le_bits();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 4 limbs\")]\n    fn test_byte_decomposition_overflow() {\n        // 4 bytes can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u8; 4] = large_val.to_le_bytes();\n    }\n\n    #[test]\n    fn test_to_from_be_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 BE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_minus_1_bytes[32 - 1] > 0);\n            p_minus_1_bytes[32 - 1] -= 1;\n\n            let p_minus_1 = Field::from_be_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_be_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 BE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_plus_1_bytes[32 - 1] < 255);\n            p_plus_1_bytes[32 - 1] += 1;\n\n            let p_plus_1 = Field::from_be_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 BE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_be_bytes();\n            assert_eq(p_plus_1_converted_bytes[32 - 1], 1);\n            p_plus_1_converted_bytes[32 - 1] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_be_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_be_bytes().len(), 32);\n            let p = Field::from_be_bytes::<32>(modulus_be_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 BE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_be_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 LE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_minus_1_bytes[0] > 0);\n            p_minus_1_bytes[0] -= 1;\n\n            let p_minus_1 = Field::from_le_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_le_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 LE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_plus_1_bytes[0] < 255);\n            p_plus_1_bytes[0] += 1;\n\n            let p_plus_1 = Field::from_le_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 LE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_le_bytes();\n            assert_eq(p_plus_1_converted_bytes[0], 1);\n            p_plus_1_converted_bytes[0] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_le_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_le_bytes().len(), 32);\n            let p = Field::from_le_bytes::<32>(modulus_le_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 LE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_le_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    /// Convert a little endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_le_bits<let N: u32>(bits: [u1; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bits().len(),\n            \"N must be less than or equal to modulus_le_bits().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    /// Convert a big endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_be_bits<let N: u32>(bits: [u1; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[N - 1 - i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    #[test]\n    fn test_to_from_be_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 BE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_minus_1_bits[254 - 1] > 0);\n            p_minus_1_bits[254 - 1] -= 1;\n\n            let p_minus_1 = from_be_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_be_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 BE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_plus_4_bits[254 - 3] < 1);\n            p_plus_4_bits[254 - 3] += 1;\n\n            let p_plus_4 = from_be_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 BE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_be_bits();\n            assert_eq(p_plus_4_converted_bits[254 - 3], 1);\n            p_plus_4_converted_bits[254 - 3] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_be_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_be_bits().len(), 254);\n            let p = from_be_bits::<254>(modulus_be_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 BE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_be_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 LE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_minus_1_bits[0] > 0);\n            p_minus_1_bits[0] -= 1;\n\n            let p_minus_1 = from_le_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_le_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 LE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_plus_4_bits[2] < 1);\n            p_plus_4_bits[2] += 1;\n\n            let p_plus_4 = from_le_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 LE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_le_bits();\n            assert_eq(p_plus_4_converted_bits[2], 1);\n            p_plus_4_converted_bits[2] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_le_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_le_bits().len(), 254);\n            let p = from_le_bits::<254>(modulus_le_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 LE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_le_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n}\n","path":"std/field/mod.nr"},"51":{"source":"use sha256::digest;\n\n// zk receipt circuit v2 - selective disclosure proofs\n// private: invoice_id, sender, recipient, amount, nonce\n// public: payment_ref, public_invoice_id, public_recipient, min_amount, max_amount\n\nglobal INVOICE_ID_LEN: u32 = 36;\nglobal WALLET_LEN: u32 = 44;\nglobal NONCE_LEN: u32 = 64;\nglobal MAX_AMOUNT_LEN: u32 = 20;\nglobal MAX_PREIMAGE_LEN: u32 = 256;\nglobal COLON: u8 = 58;\n\nfn is_zero_array<let N: u32>(arr: [u8; N]) -> bool {\n    let mut all_zero = true;\n    for i in 0..N {\n        if arr[i] != 0 {\n            all_zero = false;\n        }\n    }\n    all_zero\n}\n\n// convert u64 to decimal string bytes\nfn u64_to_string(value: u64) -> ([u8; MAX_AMOUNT_LEN], u8) {\n    let mut result: [u8; MAX_AMOUNT_LEN] = [0; MAX_AMOUNT_LEN];\n    let mut num_digits: u8 = 0;\n\n    if value == 0 {\n        result[0] = 48;\n        num_digits = 1;\n    } else {\n        let mut temp = value;\n        for _ in 0..20 {\n            if temp > 0 {\n                num_digits += 1;\n                temp /= 10;\n            }\n        }\n\n        let mut v = value;\n        for i in 0..20 {\n            if i < num_digits as u32 {\n                let digit = (v % 10) as u8;\n                let pos = (num_digits as u32) - 1 - i;\n                result[pos] = 48 + digit;\n                v /= 10;\n            }\n        }\n    }\n\n    (result, num_digits)\n}\n\n// format: \"{invoiceId}:{sender}:{recipient}:{amount}:{nonce}\"\nfn build_preimage(\n    invoice_id: [u8; INVOICE_ID_LEN],\n    sender: [u8; WALLET_LEN],\n    recipient: [u8; WALLET_LEN],\n    amount_str: [u8; MAX_AMOUNT_LEN],\n    amount_len: u8,\n    nonce: [u8; NONCE_LEN],\n) -> [u8; MAX_PREIMAGE_LEN] {\n    let mut preimage: [u8; MAX_PREIMAGE_LEN] = [0; MAX_PREIMAGE_LEN];\n    let mut pos: u32 = 0;\n\n    for i in 0..INVOICE_ID_LEN {\n        preimage[pos + i] = invoice_id[i];\n    }\n    pos += INVOICE_ID_LEN;\n    preimage[pos] = COLON;\n    pos += 1;\n\n    for i in 0..WALLET_LEN {\n        preimage[pos + i] = sender[i];\n    }\n    pos += WALLET_LEN;\n    preimage[pos] = COLON;\n    pos += 1;\n\n    for i in 0..WALLET_LEN {\n        preimage[pos + i] = recipient[i];\n    }\n    pos += WALLET_LEN;\n    preimage[pos] = COLON;\n    pos += 1;\n\n    for i in 0..MAX_AMOUNT_LEN {\n        if i < amount_len as u32 {\n            preimage[pos + i] = amount_str[i];\n        }\n    }\n    pos += amount_len as u32;\n    preimage[pos] = COLON;\n    pos += 1;\n\n    for i in 0..NONCE_LEN {\n        preimage[pos + i] = nonce[i];\n    }\n\n    preimage\n}\n\nfn main(\n    // private inputs\n    invoice_id: [u8; INVOICE_ID_LEN],\n    sender: [u8; WALLET_LEN],\n    recipient: [u8; WALLET_LEN],\n    amount: u64,\n    nonce: [u8; NONCE_LEN],\n\n    // public inputs\n    payment_ref: pub [u8; 32],\n    public_invoice_id: pub [u8; INVOICE_ID_LEN],\n    public_recipient: pub [u8; WALLET_LEN],\n    min_amount: pub u64,\n    max_amount: pub u64,\n) {\n    let (amount_str, amount_len) = u64_to_string(amount);\n\n    let preimage = build_preimage(\n        invoice_id,\n        sender,\n        recipient,\n        amount_str,\n        amount_len,\n        nonce,\n    );\n\n    let computed_hash: [u8; 32] = digest(preimage);\n\n    for i in 0..32 {\n        assert(computed_hash[i] == payment_ref[i]);\n    }\n\n    // verify disclosed invoice_id matches\n    if !is_zero_array(public_invoice_id) {\n        for i in 0..INVOICE_ID_LEN {\n            assert(invoice_id[i] == public_invoice_id[i]);\n        }\n    }\n\n    // verify disclosed recipient matches\n    if !is_zero_array(public_recipient) {\n        for i in 0..WALLET_LEN {\n            assert(recipient[i] == public_recipient[i]);\n        }\n    }\n\n    // amount range constraints\n    if min_amount > 0 {\n        assert(amount >= min_amount);\n    }\n    if max_amount > 0 {\n        assert(amount <= max_amount);\n    }\n}\n\n#[test]\nfn test_u64_to_string() {\n    let (str0, len0) = u64_to_string(0);\n    assert(len0 == 1);\n    assert(str0[0] == 48);\n\n    let (str25, len25) = u64_to_string(25);\n    assert(len25 == 2);\n    assert(str25[0] == 50);\n    assert(str25[1] == 53);\n\n    let (str123, len123) = u64_to_string(123);\n    assert(len123 == 3);\n    assert(str123[0] == 49);\n    assert(str123[1] == 50);\n    assert(str123[2] == 51);\n\n    let (_, len1m) = u64_to_string(1000000);\n    assert(len1m == 7);\n}\n\n#[test]\nfn test_basic_proof() {\n    let invoice_id: [u8; INVOICE_ID_LEN] = [\n        57, 55, 101, 102, 97, 54, 50, 57, 45, 102, 49, 98, 51, 45, 52, 102,\n        57, 57, 45, 97, 52, 98, 50, 45, 55, 56, 57, 97, 102, 50, 50, 49,\n        48, 48, 48, 49,\n    ];\n\n    let sender: [u8; WALLET_LEN] = [\n        67, 55, 68, 88, 101, 100, 71, 80, 87, 117, 71, 89, 55, 114, 102, 56,\n        68, 71, 121, 87, 118, 121, 90, 74, 75, 77, 99, 110, 104, 78, 109, 107,\n        106, 65, 97, 122, 71, 69, 113, 103, 106, 115, 109, 105,\n    ];\n\n    let recipient: [u8; WALLET_LEN] = [\n        52, 49, 56, 84, 89, 76, 86, 122, 54, 72, 111, 112, 69, 82, 72, 98,\n        57, 104, 80, 101, 121, 122, 97, 85, 88, 86, 110, 118, 113, 109, 78, 102,\n        120, 77, 80, 97, 105, 100, 81, 51, 72, 74, 86, 122,\n    ];\n\n    let amount: u64 = 25;\n\n    let nonce: [u8; NONCE_LEN] = [\n        97, 49, 98, 50, 99, 51, 100, 52, 101, 53, 102, 54, 97, 55, 98, 56,\n        99, 57, 100, 48, 101, 49, 102, 50, 97, 51, 98, 52, 99, 53, 100, 54,\n        101, 55, 102, 56, 97, 57, 98, 48, 99, 49, 100, 50, 101, 51, 102, 52,\n        97, 53, 98, 54, 99, 55, 100, 56, 101, 57, 102, 48, 97, 49, 98, 50,\n    ];\n\n    let expected_hash: [u8; 32] = [\n        13, 70, 200, 145, 60, 224, 192, 81, 5, 197, 10, 174, 177, 224, 119, 252,\n        9, 207, 155, 50, 97, 230, 91, 168, 192, 118, 35, 69, 144, 108, 148, 99,\n    ];\n\n    let (amount_str, amount_len) = u64_to_string(amount);\n    let preimage = build_preimage(invoice_id, sender, recipient, amount_str, amount_len, nonce);\n    let computed_hash: [u8; 32] = digest(preimage);\n\n    for i in 0..32 {\n        assert(computed_hash[i] == expected_hash[i]);\n    }\n}\n\n#[test]\nfn test_amount_range() {\n    let amount: u64 = 500;\n    assert(amount >= 100);\n    assert(amount <= 1000);\n}\n\n#[test]\nfn test_is_zero_array() {\n    let zeros: [u8; 4] = [0, 0, 0, 0];\n    let non_zeros: [u8; 4] = [0, 1, 0, 0];\n    assert(is_zero_array(zeros));\n    assert(!is_zero_array(non_zeros));\n}\n","path":"/Users/trivo/Documents/GitHub/solana-payroll/packages/app/circuits/zk_receipts/src/main.nr"},"60":{"source":"use std::hash::sha256_compression;\nuse std::runtime::is_unconstrained;\n\nuse constants::{\n    BLOCK_BYTE_PTR, BLOCK_SIZE, HASH, INITIAL_STATE, INT_BLOCK_SIZE, INT_SIZE, INT_SIZE_PTR,\n    MSG_BLOCK, MSG_SIZE_PTR, STATE, TWO_POW_16, TWO_POW_24, TWO_POW_32, TWO_POW_8,\n};\n\npub(crate) mod constants;\nmod tests;\nmod oracle_tests;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u32) -> HASH {\n    assert(message_size <= N);\n\n    let (h, msg_block) = process_full_blocks(msg, message_size, INITIAL_STATE);\n\n    finalize_sha256_blocks(message_size, h, msg_block)\n}\n\n/// Returns the first partially filled message block along with the internal state prior to its compression.\npub(crate) fn process_full_blocks<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    initial_state: STATE,\n) -> (STATE, MSG_BLOCK) {\n    if std::runtime::is_unconstrained() {\n        let num_full_blocks = message_size / BLOCK_SIZE;\n        // Intermediate hash, starting with the canonical initial value\n        let mut h: STATE = initial_state;\n        // Pointer into msg_block on a 64 byte scale\n        for i in 0..num_full_blocks {\n            let msg_block = build_msg_block(msg, message_size, BLOCK_SIZE * i);\n            h = sha256_compression(msg_block, h);\n        }\n\n        // We now build the final un-filled block.\n        let msg_byte_ptr = message_size % BLOCK_SIZE;\n        let msg_block: MSG_BLOCK = if msg_byte_ptr != 0 {\n            let num_full_blocks = message_size / BLOCK_SIZE;\n            let msg_start = BLOCK_SIZE * num_full_blocks;\n            build_msg_block(msg, message_size, msg_start)\n        } else {\n            // If the message size is a multiple of the block size (i.e. `msg_byte_ptr == 0`) then this block will be empty,\n            // so we short-circuit in this case.\n            [0; 16]\n        };\n\n        (h, msg_block)\n    } else {\n        let num_blocks = N / BLOCK_SIZE;\n\n        // We store the intermediate hash states and message blocks in these two arrays which allows us to select the correct state\n        // for the given message size with a lookup.\n        //\n        // These can be reasoned about as followed:\n        // Consider a message with an unknown number of bytes, `msg_size. It can be seen that this will have `msg_size / BLOCK_SIZE` full blocks.\n        // - `states[i]` should then be the state after processing the first `i` blocks.\n        // - `blocks[i]` should then be the next message block after processing the first `i` blocks.\n        // blocks[first_partially_filled_block_index] is the last block that is partially filled or all 0 if the message is a multiple of the block size.\n        //\n        // In other words:\n        //\n        // blocks = [block 1, block 2, ..., block N / BLOCK_SIZE, block N / BLOCK_SIZE + 1]\n        // states = [INITIAL_STATE, state after block 1, state after block 2, ..., state after block N / BLOCK_SIZE]\n        //\n        // We place the initial state in `states[0]` as in the case where the `message_size < BLOCK_SIZE` then there are no full blocks to process and no compressions should occur.\n        let mut blocks: [MSG_BLOCK; N / BLOCK_SIZE + 1] = std::mem::zeroed();\n        let mut states: [STATE; N / BLOCK_SIZE + 1] = [initial_state; N / BLOCK_SIZE + 1];\n\n        // Optimization for small messages. If the largest possible message is smaller than a block then we know that the first block is partially filled\n        // no matter the value of `message_size`.\n        //\n        // Note that the condition `N >= BLOCK_SIZE` is known during monomorphization so this has no runtime cost.\n        let first_partially_filled_block_index = if N >= BLOCK_SIZE {\n            message_size / BLOCK_SIZE\n        } else {\n            0\n        };\n\n        for i in 0..num_blocks {\n            let msg_start = BLOCK_SIZE * i;\n            let new_msg_block = build_msg_block(msg, message_size, msg_start);\n\n            blocks[i] = new_msg_block;\n            states[i + 1] = sha256_compression(new_msg_block, states[i]);\n        }\n        // If message_size/BLOCK_SIZE == N/BLOCK_SIZE, and there is a remainder, we need to process the last block.\n        if N % BLOCK_SIZE != 0 {\n            let new_msg_block = build_msg_block(msg, message_size, BLOCK_SIZE * num_blocks);\n\n            blocks[num_blocks] = new_msg_block;\n        }\n\n        (states[first_partially_filled_block_index], blocks[first_partially_filled_block_index])\n    }\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start` and pack them into a `MSG_BLOCK`.\npub(crate) unconstrained fn build_msg_block_helper<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> MSG_BLOCK {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if message_size < msg_start {\n        // This function is sometimes called with `msg_start` past the end of the message.\n        // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n        0\n    } else if message_size < msg_start + BLOCK_SIZE {\n        message_size - msg_start\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let int_input = (block_input + INT_SIZE - 1) / INT_SIZE;\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = (msg_item << 8) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    msg_block\n}\n\n// Build a message block from the input message starting at `msg_start`.\n//\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn build_msg_block<let N: u32>(msg: [u8; N], message_size: u32, msg_start: u32) -> MSG_BLOCK {\n    let msg_block =\n        // Safety: We constrain the block below by reconstructing each `u32` word from the input bytes.\n        unsafe { build_msg_block_helper(msg, message_size, msg_start) };\n\n    if !is_unconstrained() {\n        let mut msg_end = msg_start + BLOCK_SIZE;\n\n        let max_read_index = std::cmp::min(message_size, msg_end);\n\n        // Reconstructed packed item\n        let mut msg_item: Field = 0;\n\n        // Inclusive at the end so that we can compare the last item.\n        for k in msg_start..=msg_end {\n            if (k != msg_start) & (k % INT_SIZE == 0) {\n                // If we consumed some input we can compare against the block.\n                let msg_block_index = (k - msg_start) / INT_SIZE - 1;\n                assert_eq(msg_block[msg_block_index] as Field, msg_item);\n\n                msg_item = 0;\n            }\n\n            // If we have input to consume, add it at the rightmost position.\n            let msg_byte = if k < max_read_index { msg[k] } else { 0 };\n            msg_item = msg_item * (TWO_POW_8 as Field) + msg_byte as Field;\n        }\n    }\n    msg_block\n}\n\n// Encode `8 * message_size` into two `u32` limbs.\nunconstrained fn encode_len(message_size: u32) -> (u32, u32) {\n    let len = 8 * message_size as u64;\n    let lo = len & 0xFFFFFFFF;\n    let hi = (len >> 32) & 0xFFFFFFFF;\n    (lo as u32, hi as u32)\n}\n\n// Write the length into the last 8 bytes of the block.\nfn attach_len_to_msg_block(mut msg_block: MSG_BLOCK, message_size: u32) -> MSG_BLOCK {\n    // Safety: We assert the correctness of the decomposition below.\n    // 2 `u32` limbs cannot overflow the field modulus so performing the check as `Field`s is safe.\n    let (lo, hi) = unsafe { encode_len(message_size) };\n    assert_eq(8 * (message_size as Field), lo as Field + hi as Field * TWO_POW_32);\n\n    msg_block[INT_SIZE_PTR] = hi;\n    msg_block[INT_SIZE_PTR + 1] = lo;\n    msg_block\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\n/// Lookup table for the position of the padding bit within one of the `u32` words in the final message block.\nglobal PADDING_BIT_TABLE: [u32; 4] =\n    [(1 << 7) * TWO_POW_24, (1 << 7) * TWO_POW_16, (1 << 7) * TWO_POW_8, (1 << 7)];\n\n/// Add 1 bit padding to end of message and compress the block if there's not enough room for the 8-byte length.\n/// Returns the updated hash state and message block that will be used to write the message size.\n///\n/// # Assumptions:\n///\n/// - `msg_block[i] == 0` for all `i > msg_byte_ptr / INT_SIZE`\n/// - `msg_block[msg_byte_ptr / INT_SIZE] & ((1 << 7) * (msg_byte_ptr % INT_SIZE)) == 0`\nfn add_padding_byte_and_compress_if_needed(\n    mut msg_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    h: STATE,\n) -> (STATE, MSG_BLOCK) {\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    let index = msg_byte_ptr / INT_SIZE;\n\n    // Lookup the position of the padding bit and insert it into the message block.\n    msg_block[index] += PADDING_BIT_TABLE[msg_byte_ptr % INT_SIZE];\n\n    // If we don't have room to write the size, compress the block and reset it.\n    if msg_byte_ptr >= MSG_SIZE_PTR {\n        let h = sha256_compression(msg_block, h);\n\n        // In this case, the final block consists of all zeros with the last 8 bytes containing the length.\n        // We set msg_block to all zeros and attach_len_to_msg_block will add the length to the last 8 bytes.\n        let msg_block = [0; INT_BLOCK_SIZE];\n        (h, msg_block)\n    } else {\n        (h, msg_block)\n    }\n}\n\npub(crate) fn finalize_sha256_blocks(\n    message_size: u32,\n    mut h: STATE,\n    mut msg_block: MSG_BLOCK,\n) -> HASH {\n    let msg_byte_ptr = message_size % BLOCK_SIZE;\n\n    let (h, mut msg_block) = add_padding_byte_and_compress_if_needed(msg_block, msg_byte_ptr, h);\n\n    msg_block = attach_len_to_msg_block(msg_block, message_size);\n\n    hash_final_block(msg_block, h)\n}\n\n/**\n * Given some state of a partially computed sha256 hash and part of the preimage, continue hashing\n * @notice used for complex/ recursive offloading of post-partial hashing\n *\n * @param N - the maximum length of the message to hash\n * @param h - the intermediate hash state\n * @param msg - the preimage to hash\n * @param message_size - the actual length of the preimage to hash\n * @return the intermediate hash state after compressing in msg to h\n */\npub fn partial_sha256_var_interstitial<let N: u32>(\n    mut h: [u32; 8],\n    msg: [u8; N],\n    message_size: u32,\n) -> [u32; 8] {\n    assert(message_size % BLOCK_SIZE == 0, \"Message size must be a multiple of the block size\");\n    if std::runtime::is_unconstrained() {\n        // Safety: running as an unconstrained function\n        unsafe {\n            __sha_partial_var_interstitial(h, msg, message_size)\n        }\n    } else {\n        let (h, _) = process_full_blocks(msg, message_size, h);\n\n        h\n    }\n}\n\n/**\n * Given some state of a partially computed sha256 hash and remaining preimage, complete the hash\n * @notice used for traditional partial hashing\n *\n * @param N - the maximum length of the message to hash\n * @param h - the intermediate hash state\n * @param msg - the remaining preimage to hash\n * @param message_size - the size of the current chunk\n * @param real_message_size - the total size of the original preimage\n * @return finalized sha256 hash\n */\npub fn partial_sha256_var_end<let N: u32>(\n    mut h: [u32; 8],\n    msg: [u8; N],\n    message_size: u32,\n    real_message_size: u32,\n) -> [u8; 32] {\n    assert(message_size % BLOCK_SIZE == 0, \"Message size must be a multiple of the block size\");\n    if std::runtime::is_unconstrained() {\n        // Safety: running as an unconstrained function\n        unsafe {\n            h = __sha_partial_var_interstitial(h, msg, message_size);\n\n            // Handle setup of the final msg block.\n            // This case is only hit if the msg is less than the block size,\n            // or our message cannot be evenly split into blocks.\n\n            finalize_last_sha256_block(h, real_message_size, msg)\n        }\n    } else {\n        let (h, msg_block) = process_full_blocks(msg, message_size, h);\n        finalize_sha256_blocks(real_message_size, h, msg_block)\n    }\n}\n\nunconstrained fn __sha_partial_var_interstitial<let N: u32>(\n    mut h: [u32; 8],\n    msg: [u8; N],\n    message_size: u32,\n) -> [u32; 8] {\n    let num_full_blocks = message_size / BLOCK_SIZE;\n    // Intermediate hash, starting with the canonical initial value\n    // Pointer into msg_block on a 64 byte scale\n    for i in 0..num_full_blocks {\n        let msg_block = build_msg_block(msg, message_size, BLOCK_SIZE * i);\n        h = sha256_compression(msg_block, h);\n    }\n    h\n}\n\n// Helper function to finalize the message block with padding and length\nunconstrained fn finalize_last_sha256_block<let N: u32>(\n    mut h: STATE,\n    message_size: u32,\n    msg: [u8; N],\n) -> HASH {\n    let msg_byte_ptr = message_size % BLOCK_SIZE;\n\n    // We now build the final un-filled block.\n    let msg_block: MSG_BLOCK = if msg_byte_ptr != 0 {\n        let num_full_blocks = message_size / BLOCK_SIZE;\n        let msg_start = BLOCK_SIZE * num_full_blocks;\n        build_msg_block(msg, message_size, msg_start)\n    } else {\n        // If the message size is a multiple of the block size (i.e. `msg_byte_ptr == 0`) then this block will be empty,\n        // so we short-circuit in this case.\n        [0; 16]\n    };\n\n    // Once built, we need to add the necessary padding bytes and encoded length\n    let (h, mut msg_block) = add_padding_byte_and_compress_if_needed(msg_block, msg_byte_ptr, h);\n    msg_block = attach_len_to_msg_block(msg_block, message_size);\n\n    hash_final_block(msg_block, h)\n}\n\nmod test_process_full_blocks {\n\n    /// Wrapper to force an unconstrained runtime on process_full_blocks.\n    unconstrained fn unconstrained_process_full_blocks<let N: u32>(\n        msg: [u8; N],\n        message_size: u32,\n        h: super::STATE,\n    ) -> (super::STATE, super::MSG_BLOCK) {\n        super::process_full_blocks(msg, message_size, h)\n    }\n\n    #[test]\n    fn test_implementations_agree(msg: [u8; 100], message_size: u32) {\n        let message_size = message_size % 100;\n        // Safety: test function\n        let unconstrained_state =\n            unsafe { unconstrained_process_full_blocks(msg, message_size, super::INITIAL_STATE) };\n        let state = super::process_full_blocks(msg, message_size, super::INITIAL_STATE);\n        assert_eq(state, unconstrained_state);\n    }\n}\n\nmod test_sha256_var {\n\n    /// Wrapper to force an unconstrained runtime on sha256.\n    unconstrained fn unconstrained_sha256<let N: u32>(\n        msg: [u8; N],\n        message_size: u32,\n    ) -> super::HASH {\n        super::sha256_var(msg, message_size)\n    }\n\n    #[test]\n    fn test_implementations_agree(msg: [u8; 100], message_size: u32) {\n        let message_size = message_size % 100;\n        // Safety: test function\n        let unconstrained_sha = unsafe { unconstrained_sha256(msg, message_size) };\n        let sha = super::sha256_var(msg, message_size);\n        assert_eq(sha, unconstrained_sha);\n    }\n\n}\n","path":"/Users/trivo/nargo/github.com/noir-lang/sha256/v0.3.0/src/sha256.nr"}},"expression_width":{"Bounded":{"width":4}}}